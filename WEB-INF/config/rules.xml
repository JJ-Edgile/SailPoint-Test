<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
<Rule language="beanshell" name="No Correlator" type="Correlation"/>
<Rule language="beanshell" name="Clear CustomGlobal">
  <Source>
      
        import sailpoint.object.CustomGlobal;

        List results = new ArrayList();
        results.add("CustomGlobal BEFORE clear had ["+
                    CustomGlobal.size() + "] keys.");
        CustomGlobal.clear();
        results.add("CustomGlobal AFTER clear has [" +
                   CustomGlobal.size()+"] keys.");

        return results;
      
    </Source>
</Rule>
<Rule language="beanshell" name="IdentityNowSAML" type="SAMLCorrelation">
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
                    Logger to take care of logging.
                </Description>
      </Argument>
      <Argument name="context">
        <Description>
                    SailPointContext
                </Description>
      </Argument>
      <Argument name="assertionAttributes">
        <Description>
                    Map of attributes taken from the SAML assertion
                </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="ident">
        <Description>
                    Matching identity based on the nameId taken from assertionAttributes
                </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
        
            // Imports
            import sailpoint.object.Identity;

            // Making a BIG assumption here that the nameid-format is unspecified/persitent

            // Get the nameId from the assertionAttributes
            String nameId = (String)assertionAttributes.get("nameId");

            Identity ident;

            if(nameId != null) {
                // Lookup the identity based on nameId
                ident = context.getObject(Identity.class, nameId);
            }

            return ident;

        
    </Source>
</Rule>
<Rule language="beanshell" name="Workflow Library">
  <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.QueryOptions;
      import sailpoint.tools.Util;

      boolean otob(Object o) { return Util.otob(o); }
      boolean isTrue(Object o) {otob(o); } 
      boolean isFalse(Object o) {!otob(o); }
      boolean isNull(Object o) {o == null; } 
      int size(Collection o) { return Util.size(o); }
      String toString(Object o) {(o == null) ? "*null*" : o.toString(); }
      void println(Object o) {System.out.println(o); }
      void print(String str) { System.out.print(str); }
      void printval(String n, Object o) {println(n + " = " + toString(o)); }


      public List csvToList(String csv) {
        return Util.csvToList(csv);
      }

      /** 
       * resolve displayName by doing a projection query.
       */ 
      public String resolveDisplayName(String identityName) {
          String displayName = getIdentityProperty(identityName, "displayName"); 
          if ( displayName == null ) {
              displayName = identityName;
          }
          return displayName;
      }
      
      /** 
       * If the identityDisplayName is null resolve it by doing
       * a projection query.
       */ 
      public String resolveDisplayName(String identityName, String currentDisplayName) {
          // allow it to be passed in to avoid the query
          String displayName = null;
          if ( currentDisplayName != void ) {
              displayName = currentDisplayName;
          }
          if ( displayName == null ) {
              displayName = resolveDisplayName(identityName);
          }
          return displayName;
      }

      /**
       * Given an Identity's name, return the email address.
       */
      public String getEmail(String name) {
          return getIdentityProperty(name, "email");
      }

      /**
       * Given an Identity's name and a ProvisioningPlan, return the email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the email address from the plan.
       */
      public String getUserEmail(String name, ProvisioningPlan plan) {
          String email = getEmail(name);

          if (null == email) {
              email = getIIQCreateRequestValue(plan, "email");
          }

          return email;
      }

      /**
       * Given an Identity's name, return the manager's email address.
       */
      public String getManagersEmail(String name) {
          return getIdentityProperty(name, "manager.email"); 
      }

      /**
       * Given an Identity's name, return the manager's email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the manager from the plan to
       * lookup the email address.
       */
      public String getManagersEmail(String name, ProvisioningPlan plan) {
          String email = getManagersEmail(name);

          if (null == email) {
              String manager = getIIQCreateRequestValue(plan, "manager");
              if (null != manager) {
                  Identity identity = context.getObject(Identity.class, manager);
                  if (null != identity) {
                      email = identity.getEmail();
                  }
              }
          }

          return email;
      }

      /**
       * Return the value for the requested attribute from the ProvisioningPlan
       * if this is an identity creation request.
       */
      private String getIIQCreateRequestValue(ProvisioningPlan plan, String attr) {
          String value = null;

          if (null != plan) {
              AccountRequest acctReq = plan.getIIQAccountRequest();
              if ((null != acctReq) &amp;&amp;
                  AccountRequest.Operation.Create.equals(acctReq.getOperation())) {
                  AttributeRequest attrReq = acctReq.getAttributeRequest(attr);
                  if (null != attrReq) {
                      value = (String) attrReq.getValue();
                  }
              }
          }

          return value;
      }

      /** 
       * Return a single string property value from an identity.
       */
      public String getIdentityProperty(String identity, String property) {
          QueryOptions ops = new QueryOptions();
          Filter nameFilter = Filter.eq("name", identity);
          ops.add(new Filter[]{nameFilter});

          String val = null; 
          Iterator it = context.search(Identity.class, ops, property);
          while ( it.hasNext() ) {
              Object[] row = (Object[])it.next();
              val = (String)row[0];
              if ( it.hasNext() ) {
                  // shouldn't happen but guard
                  throw new GeneralException("More then one ["+property+"] value returned for ["+identity+"]");
              }
          } 
          return val;
      }

      /**
       * Return the value of a system configuration property.
       * The value is always returned as a string.
       */
      public String getConfiguration(String name) {
          return context.getConfiguration().getString(name);
      }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Approval Library">
  <Source>
    

    import sailpoint.api.ManagedAttributer;
    import sailpoint.object.Application;
    import sailpoint.object.ApprovalSet;
    import sailpoint.object.ApprovalItem;
    import sailpoint.object.AttributeDefinition;
    import sailpoint.object.Attributes;
    import sailpoint.object.Bundle;
    import sailpoint.object.Identity;
    import sailpoint.object.ManagedAttribute;
    import sailpoint.object.ProvisioningPlan;
    import sailpoint.object.ProvisioningPlan.AccountRequest;
    import sailpoint.object.ProvisioningPlan.AttributeRequest;
    import sailpoint.object.ProvisioningPlan.PermissionRequest;
    import sailpoint.object.ProvisioningPlan.GenericRequest;
    import sailpoint.object.ProvisioningProject;
    import sailpoint.object.Scope;
    import sailpoint.object.WorkItem;
    import sailpoint.object.Workflow;
    import sailpoint.object.Workflow.Approval;
    import sailpoint.tools.Util;
    import sailpoint.tools.xml.XMLObjectFactory;
    
    /** 
    * Take a list of AttributeRequests and return a List of Attributes
    * to store on the approval item so that we can get at the attributes of
    * each attribute request in case we need information about that attribute request
    */
    public Attributes getAttributeRequestArguments(List attributeRequests) {
      Attributes attributes = new Attributes();
      for(AttributeRequest attr : attributeRequests) {
        String key = attr.getName()+":"+attr.getValue();
        Attributes arguments = attr.getArguments();
        attributes.put(key, arguments);
      }
      return attributes;
    }

    /**
     * Turn a list of AttributeRequests into simple
     * name = 'value' format. Represent this as a list
     * so we can display it neatly in the ui tier and
     * still not mess with dn strings.
     *
     * A general utility method used both by rules and workflow
     * scripts.  
     */
    public List flattenAttributeRequests(List attributeRequests) {
        List flat = new ArrayList();
        flattenAttributeRequests(attributeRequests, flat);
        return flat;
    }
    
    /**
    *  Bug 15833, ensure requester comments make it into manual actions
    */
    public String getRequesterComments(List requests) {
        String comment = "";
        if(requests != null) {
            for(GenericRequest request : requests) {
                String innerComment = request.getComments();
                if ( Util.getString(innerComment) != null ) {
                    comment += innerComment;
                }
            }
        }
        return comment;
    }
        
    public void flattenAttributeRequests(List attributeRequests, List flat) {
        if ( Util.size(attributeRequests) &gt; 0 ) {
            for (AttributeRequest attr : attributeRequests ) {
                if( !attr.getName().equals(ProvisioningPlan.ATT_IIQ_PASSWORD) &amp;&amp;
                    !attr.getBoolean(ProvisioningPlan.ARG_SECRET) &amp;&amp;
                    !attr.getName().equals(Identity.PRF_USE_BY_DATE)) {
                    if (attr.getDisplayValue() == null) {
                        String displayName = attr.getName();
                        List val = Util.asList(attr.getValue());
                        if ( val != null ) {
                            if ( attr.getName().equals("manager") ) { 
                                String managerName = null;
                                if ( Util.size(val) == 1 ) {
                                    // For manager convert the name into a displayName so it looks 
                                    // reasonable in the ui
                                    managerName = (String)val.get(0);
                                    if ( manager != null ) {
                                        String displayName = getIdentityProperty(managerName, "displayName");
                                        if ( displayName != null ) {
                                            val = Util.csvToList(displayName);
                                        }
                                    }
                                }
                            }
                            
                            String type = (String)attr.get(ProvisioningPlan.ARG_TYPE);
                            if (type!=null &amp;&amp; type.equals(ProvisioningPlan.ARG_TYPE_DATE)) {
                              Object obj = val.get(0);
                              
                              Date date = null;
                              
                              if(obj instanceof java.util.Date) {
                                date = obj;
                              } else {
                                date = new Date((Long)obj);
                              }
                              val = new ArrayList();                         
                              val.add(Util.dateToString(date, "M/d/y"));
                            } else if (AttributeDefinition.TYPE_SCOPE.equals(type)) {
                              val = getScopeNames(val);  
                            }
                            
                        }
                        if ( Util.size(val) &gt; 0 ) 
                            flat.add(displayName+ " = '"+Util.listToCsv(val)+"'");
                    } else {
                        flat.add(attr.getDisplayValue());
                    }
                }
            }
        }
    }
    
    /*
     * Given a list of scope ids it will return a list of 
     * scope names.
     *
     */
    public List getScopeNames(List val) {
        
        if (val == null) {
            return null;
        }

        List scopeNames = new ArrayList();
        for (int i=0; i&lt;val.size(); ++i) {
            scopeNames.add(fetchScopeName((String) val.get(i)));
        }
        
        return scopeNames;
    }

    /**
     * Fetches a scope name from scope id
     *
     */    
    private String fetchScopeName(String id) {
        
        Scope scope =  context.getObjectById(Scope.class, id);
        
        if (scope == null) {
            return null;
        }
        
        return scope.getDisplayableName();
    }

    /**
     * Convert a List&lt;PermissionRequests&gt; into a List&lt;String&gt;
     * with each string formatted as "target='right,right,right'"
     * This is similar to flattenAttributeRequests above but 
     * kept distinct in case we need to change the rendering of permissions.
     * Currently it's ambiguous whether this is an attribute or a permission
     */
    public void flattenPermissionRequests(List permRequests, List flat) {

        if (permRequests != null) {
            for (PermissionRequest perm : permRequests ) {

              // we dont' have display names for targets, do we?
              flat.add(perm.getTarget() + " = '" + perm.getRights() + "'");
            }
        }
    }

    /**
     * Convert a Map&lt;String,ApprovalSet&gt; into Approval objects. 
     * One Approval object for each of the keys in the map.
     *
     * Used only by rules that calculate approval structures such
     * as LCM Build Owner Approvals.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List buildApprovalsFromMap(Map ownerToSet, String identityName, String launcher) {
        List approvals = new ArrayList();
        if ( ownerToSet == null ) 
            return null;

        Iterator keys = null;
        Set keySet = ownerToSet.keySet();
        if ( keySet != null )  
            keys = keySet.iterator();

        if ( keys != null ) {
            while ( keys.hasNext() ) {
                String key = (String)keys.next();
                if ( key == null ) continue;
                ApprovalSet set = ownerToSet.get(key);
                if ( set != null ) {
                    if ( log.isDebugEnabled() ) {
                        log.debug("Owner["+key+"] " + set.toXml());
                    }
                    // djs: check here to make sure this isn't an auto-approved 
                    // item because the approver is the launcher
                    if ( !sailpoint.workflow.IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; 
                         key.compareTo(launcher) == 0 &amp;&amp; 
                         set.isAllApproved() ) {
                        // self approved continue;
                        continue;
                    } else {
                        Approval newApproval = new Approval();
                        newApproval.setOwner("\"" + key + "\"");  // quote the owner in case the user name has a comma
                        newApproval.setApprovalSet(set);
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_CLASS, "sailpoint.object.Identity");
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_NAME, identityName);
                        approvals.add(newApproval);
                    } 
                }
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( approvals != null )
                log.debug("Approvals: " + XMLObjectFactory.getInstance().toXml(approvals));
            else
                log.debug("Approvals EMPTY.");
        }
        return approvals;
    }

    /**
     * Build a Map&lt;String,ApprovalSet&gt; each key representing a unique owner.
     * Use a Map here to allow us to easily merge any items for the same owner.
     *
     * Used by rules to build approval structures, normally followed by
     * a call to buildApprovalsFromMap.
     * 
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public Map buildOwnerMap(String scheme, ApprovalSet approvalSet, 
                             ProvisioningPlan plan, String fallbackApprover, 
                             String identity, boolean autoApprove) {

        // djs: use a LinkedHashMap here to perserve the order of the
        // approvers in the list.  This is important for manager transfer
        // approvals.
        Map ownerToSet = new LinkedHashMap();
        List items = approvalSet.getItems();
        for ( ApprovalItem item : items ) {
            List approvers = getApproverNames(scheme, item, plan, identity);
            if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                if ( log.isDebugEnabled() ) {
                    log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                }
                approvers.add(fallbackApprover);
            }
            //
            // Build an approval set or add an ApprovalItem 
            // to an existing set
            //
            if ( Util.size(approvers) &gt; 0 ) {
                for ( String approver : approvers ) {
                    ApprovalSet set = (ApprovalSet)ownerToSet.get(approver);
                    if ( set == null ) {
                        set = new ApprovalSet();
                    }

                    // Make a copy of the item here so they are independent of the the
                    // cart's item.  
                    ApprovalItem itemCopy = XMLObjectFactory.getInstance().clone(item, context);
                    set.add(itemCopy);
                    ownerToSet.put(approver, set);
                    if ( autoApprove ) {
                        // djs: when we come across the launcher who is also the approver
                        // auto approve the item, this will allow us to audit/report on
                        // the request but not force an approval.  We won't create an 
                        // Approval object if all of the items are acccepted
                        if ( approver.equals(launcher) ) {
                            itemCopy.setState(WorkItem.State.Finished);
                            if ( log.isDebugEnabled() ) {
                                log.debug("Launcher was also approver and was removed.");
                            }
                            // If there is just one approver AND we are marking this 
                            // Auto-Approved also mark the master approvalSets item 
                            // finished
                            if ( approvers.size() == 1 ) {
                                item.setState(WorkItem.State.Finished);
                            }
                        }
                    }
                }
                //
                // Update the "cart" representation
                //
                // set the item's owner so we have an update
                // version in the "registry"
                // Should we store a csv Multiple approvers ?
                item.setOwner(approvers.get(0));
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( ownerToSet != null )
                log.debug("OwnerSetMap: " + XMLObjectFactory.getInstance().toXml(ownerToSet));
            else
                log.debug("OwnerSetMap EMPTY.");
        }
        return ownerToSet;
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan, String identity) {
        return getApproverNames(scheme, item, plan, identity, null);
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan,
                                 String identity, String securityOfficerName) { 

        List owners = new ArrayList();
        String schemeToUse = scheme;
        if ( schemeToUse == null ) {
            schemeToUse = "manager";
            log.warn("Approval Scheme was not defined defaulting to manager.");
        }
        List schemes = Util.csvToList(schemeToUse);

        // None will short-circuit and cause no approvals.
        if ( schemes.contains("none") ) {
            return null;
        } 

        if ( ( schemes.contains("manager") ) || ( schemes.contains("newManager") ) ) {
            List managers = getManagers(schemes, plan, identity);
            if ( null != managers ) { 
                owners.addAll(managers);
            } 
        }

        if ( schemes.contains("owner") ) {
            String app = item.getApplication(); 
            String op = item.getOperation();
            if ( ProvisioningPlan.APP_IIQ.compareTo(app) == 0 ) { 
                if ( ( ProvisioningPlan.Operation.Add.toString().equals(op) ) || 
                     ( ProvisioningPlan.Operation.Remove.toString().equals(op) ) ) {
                    // this is a role requst, entitlement request or identity update
                    if ( ( ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(item.getName()) ) ||
                         ( ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES.equals(item.getName()) ) ) {
                        String owner = resolveRoleOwner(item);
                        if ( owner != null ) owners.add(owner);
                    } 
                }
           } else {
               String owner = resolveAppRequestOwner(item);
               if ( owner != null ) 
                  owners.add(owner);
           }
        }

        if ( schemes.contains("securityOfficer") ) {
            if (null == securityOfficerName) {
                log.warn("Security officer approval is configured but securityOfficerName is not defined.");
            }
            else {
                // Only use the security officer if it is a real identity.
                Identity officer = context.getObjectByName(Identity.class, securityOfficerName);
                if (null == officer) {
                    log.warn("Could not find securityOfficer: " + securityOfficerName);
                }
                else {
                    owners.add(securityOfficerName);
                }
            }
        }

        return owners;
    }

    /**
     * Helper for getApproverNames.
     * From the item figure out the owner that should be assigned
     * to this application request.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveAppRequestOwner(ApprovalItem item) {
        String approverName = null;

        String appName = item.getApplication();
        if ( appName == null ) return null;

        Application application = context.getObjectByName(Application.class, appName);
        if ( application == null ) 
            throw new Exception("Couldn't find application ["+appName+"]");

        Identity owner = application.getOwner();
        if ( owner != null ) {
            approverName = owner.getName();
        } else {
            // unable to find owner for application foo...
            log.debug("Unable to find owner for application ["+appName+"]");
        }

        // Check the attributeName and value and check to see if we are dealing with 
        // a ManagedAttribute 
        String attrName = item.getName();
        List vals = item.getValueList();
        if ( ( attrName != null ) &amp;&amp; ( Util.size(vals) &gt; 0 ) ) {
            // there should just be one value in each record... 
            // log something
            String val = (String)vals.get(0);
            String maOwner = getManagedAttributeOwner(application, attrName, val);
            if ( maOwner == null) {
                log.debug("Managed Attribute owner not found.. falling back to app owner.");
            } else {
                approverName = maOwner;
            }
        }
        return approverName;
    }

    /**
     * Helper for resolveAppRequestOwner.
     * Use the ManagedAttributer to find the managed attribute and get the
     * owner from the ManagedAttribute.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String getManagedAttributeOwner(Application app, String name, String value ) {
        String owner = null;
        ManagedAttribute ma = ManagedAttributer.get(context, app.getId(), name, value);
        if ( ma != null ) {
            Identity maOwner = ma.getOwner();
            if ( maOwner != null ) 
                owner = maOwner.getName();
        }
        return owner;
    }

    /**
     * Helper for getApproverNames.
     * If its a role request look up the role by name and get the owner
     * from the Role object.  
     *
     * TODO: should I walk up the hierarchy here if ther isn't 
     * one on the Bundle?
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveRoleOwner(ApprovalItem item) {
        String approverName = null;
        List values = item.getValueList();
        if ( Util.size(values) &gt; 0 ) {
            if ( Util.size(values) != 1 ) 
                throw new Exception("More then one value found in an approval item");

            String roleName = (String)values.get(0);
            if ( roleName != null ) {
                Bundle b = context.getObjectByName(Bundle.class, roleName);
                if ( b != null ) {
                    Identity id = b.getOwner();
                    if ( id != null ) {
                        approverName = id.getName();
                    }
                }
            }
        }
        return approverName;
    }

    /**
     * Helper for getApproverNames.
     * Get the value for manager or other by resolving the identity
     * and computing the manager, or validating the value
     * in the approvalScheme variable;
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private List getManagers(List schemes, ProvisioningPlan plan, String identity) {
        //  
        //  During Identity Creates the Identity object does not exist
        //    In this case we have to look at the plan and see if one is assigned
        //    if not assigned default to the fallbackApprover
        // 
        //  During Updates there could be one or two managers in play
        //    1) Newly assigned manager (which is still in the plan)
        //    2) Currently assigned manager ( assigned to the identity )
        //    
        List approverNames = new ArrayList();

        String currentManager = null;
        // Use the identities manager to resolve the approval
        Identity identityObject = context.getObject(Identity.class, identity);
        if ( identityObject != null ) {
            Identity manager = identityObject.getManager();
            if ( manager != null ) {
                currentManager = manager.getName();
            } else {
                log.debug("Manager not found for ["+identityObject.getName()+"] while computing approval");
            }
        }

        String planManager = resolveManagerFromPlan(plan);
        if ( ( currentManager == null ) &amp;&amp; ( planManager != null ) ) {
            // likely Identity Create case
            approverNames.add(planManager);
        } else
            if ( ( currentManager != null ) &amp;&amp; ( planManager == null ) ) {
                // normal case
                approverNames.add(currentManager);
            } else
                if ( ( currentManager != null ) &amp;&amp; ( planManager != null ) ) {
                    // Manager Transfer
                    if ( schemes.contains("manager") ){
                        approverNames.add(currentManager);
                    }
                    if ( schemes.contains("newManager") ){
                        approverNames.add(planManager);
                    } 
                }
        return ( approverNames.size() &gt; 0 ) ? approverNames : null;
    }

    /**
     * Helper for getManagers.
     * Dig into the plan and find the manager attribute for the IIQ
     * app if present. This is used during manager transfers
     * where we need to know the new manager so they can be 
     * part of the approval process.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveManagerFromPlan(ProvisioningPlan plan )  {
        String managerName = null;
        if ( plan != null ) {
            AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);
            if ( iiq != null ) {
                AttributeRequest manager = iiq.getAttributeRequest("manager");
                if ( manager != null ) {
                    Object obj = manager.getValue();
                    if ( obj != null ) {
                        managerName = Util.getString(obj.toString());
                    }
                }
            }
        }
        return managerName;
    }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Build Manual Action Approvals">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ApprovalItem;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.ProvisioningPlan.AccountRequest;
       import sailpoint.service.ProvisioningTransactionService;
       import sailpoint.service.ProvisioningTransactionService.TransactionDetails;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // project - Provisioning Project
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //

       List approvals = null;
       ProvisioningPlan unmanaged = project.getUnmanagedPlan();
       if ( unmanaged != null ) {
           // 
           // Build an ApprovalSet from each of the things in the plan 
           // 
           Identity id = context.getObject(Identity.class, identityName);
           ApprovalSet set = new ApprovalSet();
           for ( AccountRequest acctReq : unmanaged.getAccountRequests() ) {
               ProvisioningTransactionService transService = new ProvisioningTransactionService(context);

               AccountRequest account = new AccountRequest(acctReq.toMap());
               if ( AccountRequest.Operation.Create.equals(account.getOperation()) ) {
                   ApprovalItem item = new ApprovalItem();
                   // need to deal with this 
                   item.setApplication(account.getApplication());
                   item.setInstance(account.getInstance());
                   item.setNativeIdentity(account.getNativeIdentity());
                   AccountRequest.Operation op = account.getOperation();
                   if (op == null) {
                       // shouldn't be here but assume modify
                       op = AccountRequest.Operation.Modify;
                   }
                   item.setOperation(op.toString());
                   
                   //MEH 15833, get those comments transferred to the new approval item!
                   String requesterComments = null;
                   String attrComments = getRequesterComments(account.getAttributeRequests());
                   String permComments = getRequesterComments(account.getPermissionRequests());
                   
                   //only one of these should be set... ideally
                   if(attrComments.length() &gt; 0) {
                      requesterComments = attrComments;
                   }
                   
                   if(permComments.length() &gt; 0) {
                      requesterComments = permComments;
                   }

                   if(requesterComments == null) {
                      if(account.getComments() != null) {
                         requesterComments = account.getComments();
                      }
                   }

                   item.setRequesterComments(requesterComments);

                   List reqs = new ArrayList();
                   
                   flattenAttributeRequests(account.getAttributeRequests(), reqs);
                   flattenPermissionRequests(account.getPermissionRequests(), reqs);

                   item.setValue(reqs);
                   set.add(item);
               } else {
                   // The default ApprovalSet builder creates an ApprovalItem for
                   // every attribute/permission request
                   IdentityLibrary.addApprovalItems(id, account, set);
               }

               TransactionDetails details = new TransactionDetails();
               details.setIdentityName(identityName);
               details.setProject(project);
               details.setRequest(account);
               details.setPartitionedPlan(unmanaged);
               details.setManual(true);

               if (project.getMasterPlan() != null) {
                   details.setSource(project.getMasterPlan().getSource());
               }

               transService.logTransaction(details);
           }
           // 
           // Build a map of owner to ApprovalSet from each of the items
           // in the unmanaged plan 
           // 
           // Default to the owner scheme, but we might need an option 
           // 
           Map ownerMap = buildOwnerMap("owner", set, unmanaged, fallbackApprover, identityName, false);
           if ( ownerMap != null ) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           }
       }
       return approvals;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Workflow Library">
  <Source>
    
      import sailpoint.api.Provisioner;
      import sailpoint.api.SailPointFactory;
      import sailpoint.api.SailPointContext;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.AuditEvent;
      import sailpoint.object.Comment;
      import sailpoint.object.Field;
      import sailpoint.object.Form;
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningProject;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.SignOffHistory;
      import sailpoint.object.Source;
      import sailpoint.object.Workflow;
      import sailpoint.object.Workflow.Approval;
      import sailpoint.object.WorkItem;
      import sailpoint.object.WorkItem.OwnerHistory;
      import sailpoint.server.Auditor;
      import sailpoint.tools.Util;
      import sailpoint.workflow.IdentityLibrary;
      import sailpoint.workflow.WorkflowContext;

      /**
       * Build an event per forward so there is a record 
       * that the owner changed from the original 
       * owner.
       */
      public void auditWorkItemOwnerHistory(WorkItem item) {
          List ownerHistories = item.getOwnerHistory();
          if ( Util.size(ownerHistories) &gt; 0 ) {
              String action = "Forward";
              if ( Auditor.isEnabled(action) ) {
                  for ( OwnerHistory history : ownerHistories ) {
                      AuditEvent event = new AuditEvent();
                      event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                      event.setAction(action);
                      event.setTarget(item.getTargetName());
                      event.setAttribute("workitem", item.getName());
                      String oldOwner = history.getOldOwner();
                      if ( oldOwner != null ) 
                          event.setAttribute("oldOwner", oldOwner);
                      String source = history.getEffectiveSource();
                      event.setSource(source);
                      String comment = history.getComment();
                      if ( comment != null ) 
                          event.setAttribute("comment", comment);
                      String newOwner = history.getNewOwner();
                      if ( newOwner != null ) 
                          event.setAttribute("newOwner", newOwner);

                      // djs: for now set this in both places to avoid needing
                      // to upgrade.  Once we have ui support for "interface"
                      // we can remove the map version
                      event.setAttribute("interface", Source.LCM.toString());
                      event.setInterface(Source.LCM.toString());

                      Auditor.log(event);
                  }
              }
          }
      }

      /**
       * Build a single "comment" event for all of the comments
       * that were entered during a workitems lifecycle.
       */
      public void auditWorkItemComments(WorkItem item) {
          List comments = item.getComments();
          if ( Util.size(comments) &gt; 0 ) {
              String action = "Comment";
              if ( Auditor.isEnabled(action) ) {
                  AuditEvent event = new AuditEvent();
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  event.setAction(action);
                  event.setTarget(item.getTargetName());
                  event.setAttribute("workitem", item.getName());

                  List commentStrings = new ArrayList();
                  for ( Comment comment : comments ) {
                      commentStrings.add(comment.toString());
                  }
                  event.setAttribute("comments", commentStrings);
                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", Source.LCM.toString());
                  event.setInterface(Source.LCM.toString());
                  Auditor.log(event);
              }
          }
      }

      /**
       * Determine the name to use as the "source" of an LCM work item
       * completion audit.  This should be the name of the identity that
       * closed the item.  This will be different than the item owner if the
       * owner is a work group.
       */
     public String getAuditSource(WorkItem item) {

         String actor = context.getUserName();
         Identity ident = context.getObjectByName(Identity.class, actor);
         if (ident != null)
             actor = ident.getDisplayName();
         else {
             // must be in the background with a pseudo system name
             // fall back to item owner
             ident = item.getOwner();
             if (ident != null)
                 actor = ident.getDisplayName();
             else 
                 actor = launcher;
         }

         return actor;
     }

      public void auditDecisions(WorkItem item) {
          if ( item == null )  return; 

          // there is only one Signoff, duplicated for each approval item
          SignOffHistory signoff = null;
          List signoffs = item.getSignOffs();
          if (signoffs != null &amp;&amp; signoffs.size() &gt; 0)
              signoff = (SignOffHistory)signoffs.get(0);

          ApprovalSet approvalSet = (ApprovalSet)item.get("approvalSet");
          if ( ( approvalSet != null ) &amp;&amp; ( !approvalSet.isEmpty() ) ) {
              for ( ApprovalItem it : approvalSet.getItems() ) {

                  /** Assimilate the form field changes back into the attribute requests before
                  * creating the audit event so that the correct data is stored in the audit event. **/
                  List attrs = it.getIIQAttributes();
                  Form form = (Form)item.get("workItemForm");
                  if(attrs!=null &amp;&amp; form!=null) {
                    for(AttributeRequest attr : attrs) {
                      
                      Field field = form.getField(it.getApplication()+":"+attr.getName());
                      if(field!=null) {
                        attr.setValue(field.getValue());
                      }
                    }
                    it.setValue(flattenAttributeRequests(attrs));                 
                  }
                                    
                  AuditEvent event = new AuditEvent();
                  event.setAction(AuditEvent.ActionApproveLineItem);
                  event.setSource(getAuditSource(item));
                  event.setTarget(identityName);

                  event.setApplication(it.getApplication());
                  event.setAccountName(it.getNativeIdentity());
                  event.setInstance(it.getInstance());
                  event.setAttributeName(it.getName());
                  event.setAttributeValue(it.getCsv());                  
                  
                  // electronic signature
                  if (signoff != null) {
                     String meaning = signoff.getText();
                     if (meaning != null) {
                         event.setAttribute("esignatureSigner", 
                                            signoff.getSignerDisplayableName());
                         event.setAttribute("esignatureText", meaning);
                         // what else, date?
                     }
                 }

                  Date start = it.getStartDate();
                  if ( start != null ) 
                      event.setAttribute("startDate", start);
                  Date end = it.getEndDate();
                  if ( end != null ) 
                      event.setAttribute("endDate", end);

                  event.setAttribute("currentStep", wfcontext.getStep().getName());

                  // group them by a generatedId
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  String interfaceName = wfcontext.getString("interface");
                  if ( interfaceName == null)
                      interfaceName = Source.LCM.toString();

                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", interfaceName);
                  event.setInterface(interfaceName);

                  event.setAttribute("operation", it.getOperation());
                  event.setAttribute("requester", launcher);

                  List comments = it.getComments();
                  if ( Util.size(comments) &gt; 0 ) {
                      event.setAttribute("completionComments", comments);
                  }

                  String requesterComments = it.getRequesterComments();
                  if ( Util.getString(requesterComments) != null )
                      event.setAttribute("requesterComments", requesterComments);

                  String taskResultId = wfcontext.getString(Workflow.VAR_TASK_RESULT);
                  if ( taskResultId != null ) {
                      event.setAttribute(Workflow.VAR_TASK_RESULT, taskResultId);
                  }

                  if ( !it.isApproved() ) {
                      event.setAction(AuditEvent.ActionRejectLineItem);
                  }

                  if ( Auditor.isEnabled(event.getAction()) ) {
                      Auditor.log(event);
                      wfcontext.getSailPointContext().commitTransaction();
                  }
              }
          }
      }

      public void auditManualAction(WorkItem item) {
          if ( Auditor.isEnabled(AuditEvent.ManualChange) ) {
              ApprovalSet set = (ApprovalSet)item.get("approvalSet");
              if ( set != null ) {
                  List items = set.getItems();
                  if ( Util.size(items) &gt; 0 ) {
                      int num = 0 ;
                      for ( ApprovalItem it : items  ) { 
                          num++;
                          AuditEvent event = IdentityLibrary.buildBaseEvent(wfcontext, it);
                          event.setSource(getAuditSource(item));
                          event.setAction(AuditEvent.ManualChange);
                          event.setAttribute("requester", wfcontext.getString("launcher"));
                          event.setAttribute("op", it.getOperation());
                          List comments = it.getComments();
                          if ( Util.size(comments) &gt; 0 ) {
                              event.setAttribute("completionComments", comments);
                          }
                          Auditor.log(event);
                      }
                      if ( num &gt; 0 ) 
                          wfcontext.getSailPointContext().commitTransaction();
                  }
              } else {
                  throw new GeneralException("ApprovalSet not found in the afterscript.");
              }
          } 
      }

      /**
       * After an approval has been made apply the changes from the workitem back into the
       * cart. (approvalSet)
       */
      public void assimilateWorkItemApprovalSet(WorkflowContext wfcontext, WorkItem item, ApprovalSet approvalSet) {
         if (item == null) {
              // must not be a leaf approval...
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          // 
          // Also audit the comments and forwarding thats happend
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              String ownerName = null;
              Identity id = item.getOwner();
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in the afterscript.");
          }
          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
          wfcontext.getSailPointContext().commitTransaction();
      }

      /**
       * Convert the approvalScheme to csv and check for the approvalType.
       */
      public boolean isApprovalEnabled(String approvalScheme, String approvalType) {
          if ( approvalScheme != null )  {
              List schemes = Util.csvToList(approvalScheme);
              if ( Util.size(schemes) &gt; 0 ) {
                  if ( schemes.contains(approvalType) ) {
                      return true;
                  }
              }
          }
          return false;
      }

      public String getManagerName(String identityName, String launcher, String fallbackApprover) {
          String managerName = getIdentityProperty(identityName, "manager.name");
          if ( managerName != null ) {
              if ( managerName.compareTo(launcher) == 0 ) {
                  managerName = null;
              } 
          } else {
             managerName = fallbackApprover;
          }
          return managerName;
      }

      /**
       * Take an ApprovalSet and allow filtering of rejected items and 
       * allow clearing decisions. If includeRejected is false, only non rejected 
       * items will be copied into the new approvalSet.   If forceDecision is
       * true all of the previous decisions will be cleared forcing the new
       * approver to make a decision on all items.
       */
      public ApprovalSet filterApprovalSet(ApprovalSet masterSet, String includeRejected, 
                                           boolean forceDecision) {
          ApprovalSet filtered = new ApprovalSet();
          if ( masterSet != null ) {
              List items = masterSet.getItems();
              if ( !Util.otob(includeRejected) ) {
                  items = new ArrayList();
                  for ( ApprovalItem item : masterSet.getItems() ) {
                      if ( !item.isRejected() ) {
                          items.add(item);
                      }
                  }
              }
 
              if ( Util.size(items) &gt; 0 )  {
                  for ( ApprovalItem item : items ) {
                      if ( forceDecision ) { 
                          item.setState(null);
                      }
                      filtered.add(item); 
                  } 
              } 
          }
          return filtered;
      }

      //Filter items from the currentSet that are rejected in the masterSet
      public void filterRejectsFromApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null &amp;&amp; globalItem.isRejected()) {
                    //remove from the current approval
                    it.remove();
                }
            }
        }

      }

      //Set decisions on the currentSet to those in the masterSet
      public void setPreviousDecisionsOnApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null) {
                    currentItem.setState(globalItem.getState());
                }
            }
        }
      }

    
  </Source>
</Rule>
<Rule language="beanshell" name="Check Password Policy" type="FieldValue">
  <Source>
    
       import sailpoint.api.PasswordPolice;
       import sailpoint.object.Application;
       import sailpoint.object.Identity;
       import java.util.List;
       import java.util.ArrayList;
       import sailpoint.api.PasswordPolicyException;
       import sailpoint.tools.Util;
       import sailpoint.tools.Message;
       import sailpoint.tools.GeneralException;

       List msgs = new ArrayList();

       String passVal = (String)value;

       try {
           String appname = field.getApplication();
           if (appname == null) {
              // temporary support old WorkItems
              String fname = field.getName();
              int colon = fname.indexOf(":");
              if (colon &gt; 0)
                 appname = fname.substring(0, colon);
              else
                 log.error("Unable to determine application name from field");
           }
           Application app = context.getObjectByName(Application.class, appname);
          
           PasswordPolice police = new PasswordPolice(context);
           police.checkPassword(app, identity, passVal);
       }
       catch (PasswordPolicyException pe) {
           List messages = pe.getAllMessages();
           for (Message msg : messages) {
               msgs.add(msg.getMessage());
           }
       }
       catch (GeneralException ge) {
           msgs.add(ge.getMessage());
       }

       return ( Util.size(msgs) &gt; 0 ) ? msgs: null;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Owner Approvals">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalSet - An ApprovalSet representing the "cart"
       // 
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       //
       List approvals = new ArrayList();
       if ( approvalSet != null ) {
           // 
           // Build a map of owner to ApprovalSet from each of the things in the plan 
           // 
           Map ownerMap = buildOwnerMap("owner", approvalSet, plan, fallbackApprover, identityName, !IdentityLibrary.isElectronicSignatureEnabled(wfcontext));
           if ( ownerMap != null) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           } 
       }
       return ( Util.size(approvals) &gt; 0 ) ? approvals : null;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Identity Approvers">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.WorkItem.State;
       import sailpoint.workflow.IdentityLibrary;
       import sailpoint.tools.Util;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalScheme - String indicating how approvals should be generated
       //   none - disabled
       //   manager - the current manager gets the approval
       //   newManager - the current manager if the manager changd
       //   securityOfficer - the configured security officer
       // 
       // approvalSet - An ApprovalSet representing the "cart"
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       // launcher - name of the identity that launched the request
       //
       // securityOfficerName - The name of the securityOfficer to be used
       //                       for approvals.
       //

       // Not all callers pass in securityOfficerName.  If not defined, just set
       // it to null so we don't run into an error when we try to reference it.
       if (void == securityOfficerName) {
           securityOfficerName = null;
       }

       List approvers = new ArrayList();
       if ( approvalSet != null ) {
           List items = approvalSet.getItems();
           // By default there is one item for all of the edits
           ApprovalItem item = null;
           if ( Util.size(items) &gt; 0 ) 
               item = items.get(0); 

           if ( item != null ) {
               approvers = getApproverNames(approvalScheme, item, plan, identityName, securityOfficerName);
               if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                   if ( log.isDebugEnabled() ) { 
                       log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                   }
                   approvers.add(fallbackApprover);
               } 
               // If the launcher is an approver remove them from the list
               if ( approvers != null &amp;&amp; approvers.contains(launcher) ) {
                   Map args = wfcontext.getArguments();
                   String esig = null;
                   if ( args != null ) 
                       esig = (String)args.get("approverElectronicSignature");
 
                   if ( !IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; Util.isNullOrEmpty(esig) ) {
                       approvers.remove(launcher);
                       // If this is the only approver automaticaly
                       // mark the item approved.
                       if ( Util.size(approvers) == 0 ) {
                           item.setState(WorkItem.State.Finished);
                           item.setOwner(launcher);
                       }
                   }
               }
           }
       }
       return approvers;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Validate Identity Name" type="Validation">
  <Source>
    
      import sailpoint.api.*;
      import sailpoint.object.*;
      import sailpoint.tools.*;
      import sailpoint.api.*;
      import sailpoint.web.messages.MessageKeys;

      QueryOptions qo = new QueryOptions();
      Filter filter  = Filter.ignoreCase(Filter.eq("name", value));
      qo.add(new Filter[]{filter});
      qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());
      int count = SailPointFactory.getCurrentContext().countObjects(Identity.class,qo);
      List messages = new ArrayList();
      if (count&gt;0) {
          Message msg = new Message();
          msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NAME_ERROR);
          messages.add(msg);
      }
      return messages;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Validate Password" type="Validation">
  <Source>
    
      import java.util.*;
      import sailpoint.api.PasswordPolice;
      import sailpoint.api.PasswordPolicyException; 
      
      List errors = null;
      
      try {
          PasswordPolice pp = new PasswordPolice(context);
          pp.checkPassword(null, value, false);
      }
      catch (PasswordPolicyException ppe) {
          errors = new ArrayList();
          errors.addAll(ppe.getAllMessages());
      }
      
      return errors;
    
  </Source>
</Rule>
<Rule language="beanshell" name="LCM Build Identity ApprovalSet">
  <ReferencedRules>
    <Reference class="sailpoint.object.Rule" name="Approval Library"/>
  </ReferencedRules>
  <Source>
    
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.Attributes;
      import sailpoint.tools.Util;

      ApprovalSet set = new ApprovalSet();
      if ( plan != null ) {
          List accountRequests = plan.getAccountRequests();
          for ( AccountRequest request : accountRequests ) {
              ApprovalItem item = new ApprovalItem();
              item.setApplication(request.getApplication());
              item.setInstance(request.getInstance());
              item.setNativeIdentity(request.getNativeIdentity());
              item.setOperation(request.getOperation().toString());
              List attrRequestFlat = flattenAttributeRequests(request.getAttributeRequests());
              if ( attrRequestFlat != null ) {
                  item.setValue(attrRequestFlat);
              } 
              Attributes attributes = getAttributeRequestArguments(request.getAttributeRequests());
              item.setAttributes(attributes);
              
              // for these requests comments come in on the plan
              String comments = plan.getComments();
              if ( Util.getString(comments) != null ) {
                  item.setRequesterComments(comments);
              }
              set.add(item);
          }

          // while we are here lets annotate the plan with previousValues
          if ( flow.equals("IdentityEditRequest") ) {
              AccountRequest iiqRequest = plan.getAccountRequest("IIQ");    
              if ( iiqRequest != null ) {
                  List attributeRequests = iiqRequest.getAttributeRequests();
                  if ( Util.size(attributeRequests) &gt; 0 ) {
                      Identity id = context.getObject(Identity.class, identityName);
                      if ( id != null )  {
                          for ( AttributeRequest req : attributeRequests ) {
                              String name = req.getName();
                              if ( name != null ) {
                                  // We have to be carefull here, if we see manager display
                                  // the displayName
                                  Object prevValue = id.getAttribute(name);
                                  if ( prevValue != null ) {
                                      if (name.equals("manager") ) {
                                          String displayName = getIdentityProperty((String)prevValue, "displayName");
                                          if ( displayName != null ) {
                                              prevValue = displayName;
                                          }
                                      }
                                      else if (prevValue instanceof Identity) {
                                          prevValue = (String)prevValue.getDisplayableName();
                                      }
                                      else  if(prevValue instanceof List) {
                                          /* Thanks to type erasure there is no way for us to write something like
                                           * prevValue instanceof List&lt;Identity&gt; so break it into steps.  Check if
                                           * prevValue is a List.  If it has any elements get the first one. If that
                                           * is an instance of Identity then assume the rest of the elements are too
                                           * and then build a List of displayable names, because that is what we do
                                           * with Identitys. */
                                          List prevValueList = (List) prevValue;
                                          if(prevValueList.size() &gt; 0) {
                                              if(prevValueList.get(0) instanceof Identity) {
                                                  List identityIds = new ArrayList(prevValueList.size());
                                                  for (Object value : prevValueList) {
                                                      Identity identity = (Identity) value;
                                                      identityIds.add(identity.getDisplayableName());
                                                  }
                                                  prevValue = identityIds;
                                              }
                                          }
                                      }
                                      req.put(ProvisioningPlan.ARG_PREVIOUS_VALUE, prevValue);
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
      return set;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestor's Authorized Scopes" type="RequestObjectSelector">
  <Description>
    This rule returns either a Filter object that will be used to search for objects in the requestor's authorized scopes,
    the boolean value 'true' to indicate that everything should be returned (i.e. no restrictions) 
    or the boolean value 'false' to indicate that no objects are available for this user
  </Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.api.ScopeService;
      
      ScopeService scopeService = new ScopeService(context);
      return scopeService.getControlledScopesQueryInfo(requestor);
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestee's Assigned Scope" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts objects to those in the requestee's assigned scope</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.api.ScopeService;
      import sailpoint.object.Identity;
      import sailpoint.object.Scope;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo;

      ScopeService scopeService = new ScopeService(context);
      QueryInfo scopeQueryInfo;
      if (requestee == null) {
          scopeQueryInfo = new QueryInfo(new QueryOptions());
      } else {
          scopeQueryInfo = scopeService.getAssignedScopeQueryInfo(requestee);
      }
      
      return scopeQueryInfo;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects in Requestor's Authorized Scopes or Requestee's Assigned Scope" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts roles to those in the requestor's authorized scopes or the requestee's assigned scope</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
        import sailpoint.api.ScopeService;
        import sailpoint.object.Filter;
        import sailpoint.object.Identity;
        import sailpoint.object.QueryInfo;
        import sailpoint.object.QueryOptions;        

        ScopeService scopeService = new ScopeService(context);
        QueryInfo requestorQueryInfo =  scopeService.getControlledScopesQueryInfo(requestor);
        QueryInfo requesteeQueryInfo;
        if (requestee == null) {
            requesteeQueryInfo = null;
        } else {
            requesteeQueryInfo =  scopeService.getAssignedScopeQueryInfo(requestee);
        }

        QueryInfo scopeQueryInfo;
        if (requesteeQueryInfo == null || requesteeQueryInfo.isReturnNone()) {
            // Either no requestee was available or the requestee doesn't have anything in scope.  
            // Only apply the requestor QueryInfo in either case.
            scopeQueryInfo = requestorQueryInfo;
        } else if (requestorQueryInfo != null &amp;&amp; !requestorQueryInfo.isReturnNone()) {
            if (requestorQueryInfo.isReturnAll() || requesteeQueryInfo.isReturnAll()) {
                // If either the requestor or requestee has access to everything create a QueryInfo that grants
                // access to everything
                scopeQueryInfo = new QueryInfo(new QueryOptions());
            } else {
                // Both requestee and requestor filters exist so 'or' them
                scopeQueryInfo = new QueryInfo(Filter.or(requestorQueryInfo.getFilter(), requesteeQueryInfo.getFilter()), false);
            }
        } else {
            // The requestor doesn't have access to anything so only return whatever the requestee has access to
            scopeQueryInfo = requesteeQueryInfo;
        }

        return scopeQueryInfo;
    
  </Source>
</Rule>
<Rule language="beanshell" name="Objects Owned by the Requestor" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts objects to those that the requestor or one of their workgroups owns</Description>
  <Signature returnType="sailpoint.object.QueryInfo">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected object.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible Objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo; 
      return new QueryInfo(QueryOptions.getOwnerScopeFilter(requestor, "owner"), false);
    
  </Source>
</Rule>
<Rule language="beanshell" name="All Objects" type="RequestObjectSelector">
  <Description>Allows all objects to be selected (no filtering)</Description>
  <Signature returnType="sailpoint.object.Filter">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible request objects.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.QueryInfo;

return new QueryInfo(null, false);</Source>
</Rule>
<Rule language="beanshell" name="Identity Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, null,
          "Identity Attributes", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, null,
          "Identity Extended Attributes", locale, "id");


       
</Source>
</Rule>
<Rule language="beanshell" name="Identity Entitlement Identity Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes accessed through an identity entitlement.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, standardAttributes, "identity",
          "Identity Attributes", locale, "id");


        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, extendedAttrs, "identity",
          "Identity Extended Attributes", locale, "id");


       
</Source>
</Rule>
<Rule language="beanshell" name="Account Report Form Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for all searchable account fields.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Account Properties", locale);
       
</Source>
</Rule>
<Rule language="beanshell" name="Certification Report Customizer" type="ReportCustomizer">
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.tools.Util;
        import sailpoint.web.messages.MessageKeys;
        if (Util.otob(taskDefinition.getArgument("exclusions"))){
          report.setDisablePreview(true);
          report.setDisablePreviewMessage(MessageKeys.REPT_CERT_PREVIEW_DISABLED_EXCLUSIONS);
        } else {
          report.setDisablePreview(false);
          report.setDisablePreviewMessage(null);
        }

       
</Source>
</Rule>
<Rule language="beanshell" name="Privileged Access Report Customizer" type="ReportCustomizer">
  <Description>
    This rule populates a form with fields for the standard and extended identity attributes as well as
    a form for defining the 'privileged' identity attribute.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="locale">
        <Description>
          The current user's locale
        </Description>
      </Argument>
      <Argument name="report">
        <Description>
          The base report
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Privileged Account Attributes", locale, "id");


        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, "identity",
          "Identity Properties", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, "identity",
          "Identity Extended Properties", locale, "id");
       
</Source>
</Rule>
<Rule language="beanshell" name="Privileged Access Report Validation Rule" type="ReportValidator">
  <Description>
      This rule validates the Privileged Access Report Form
    </Description>
  <Signature returnType="java.util.List">
    <Inputs>
      <Argument name="context">
        <Description>
            A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
          </Description>
      </Argument>
      <Argument name="report">
        <Description>
            The report object
          </Description>
      </Argument>
      <Argument name="form">
        <Description>
            The submitted sailpoint Form object.
          </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="messages">
        <Description>
            A list of error messages.
          </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      
       import java.util.*;
       import sailpoint.object.*;
       import sailpoint.tools.Message;
       List messages = new ArrayList();

       Form.Section section = form.getSection("Privileged Account Attributes");
       if (section != null) {
         boolean found = false;
         for(FormItem item : section.getItems()){
           Field field = (Field)item;
           if(field.getValue() != null &amp;&amp; !field.getValue().equals("") &amp;&amp; !field.getValue().equals("null")) {
             found = true;
           }
         }

         if (!found) {
           messages.add(Message.localize("rept_priv_access_err_no_attr"));
         }
       } else {
         messages.add(Message.localize("rept_priv_attr_setup_needed"));
       }

       return messages;
      
  </Source>
</Rule>
<Rule language="beanshell" name="WindowsActivityRuleLibrary">
  <Source>
    
      import java.util.HashMap;
      import java.util.ArrayList;
      import java.util.List;
      import sailpoint.object.ApplicationActivity;
      import sailpoint.object.ApplicationActivity.Action;
      import sailpoint.tools.xml.*;

      public static String ACCESSES = "Accesses";
      public static String PRIVS = "Privileges";

      /**
       * Build a name,value Map pairing of the data found
       * in the Message field of the windows event.
       * Most of the low-level data is usually stored 
       * there using a "name : value \n" format, so parse
       * out those values so we can use them when 
       * building our activity.
       */
      public HashMap buildMapFromMessage(String message) {
  
          HashMap attributeMap = new HashMap();
          if ( message == null ) return attributeMap;

          StringTokenizer st = new StringTokenizer(message, "\n");
          int tokenNum = 0;
          while ( st.hasMoreTokens() ) {
              tokenNum++;
              String token = st.nextToken();
//System.out.println("token :" + token);
              String[] values = token.split(":");
              if ( values == null ) continue;
              if ( values.length == 2 ) {
                  String name = values[0];
                  String value = values[1];
                  if ( ( name != null ) &amp;&amp; ( value != null ) ) {
//System.out.println("name: " + name.trim() + " value: " + value.trim());
                      attributeMap.put(name.trim(), value.trim());
                  }
              } else 
              if ( (values.length == 1) &amp;&amp; (tokenNum == 1) ) {
                  String name = values[0];
                  attributeMap.put("action", name.trim());
              }
          }
          // Parse out privs 
          addPrivileges(attributeMap, message); 

          return attributeMap;
      }

      /** 
       * Some events, mostly Object Access events contain
       * Accesses, Privleges that need to be parsed further.
       * This is called, when we build a Map if the Message.
       */
      public void addPrivileges(HashMap extraInfo, String message) {

          if ( message== null ) return;
          int i = message.indexOf(ACCESSES);
          if ( i == -1 ) {
//System.out.println(ACCESSES + " not found");
              return;
          }
          int j = message.indexOf(PRIVS);
          if ( j == -1 ) {
//System.out.println(PRIVS + " not found");
              return;
          }

          List accesses = new ArrayList();
          String lastBlock = message.substring(i+ACCESSES.length(), j-1);
          if ( lastBlock != null ) {
//System.out.println("***lastBlock: " + lastBlock);
              StringTokenizer st = new StringTokenizer(lastBlock, "\n");
              while ( st.hasMoreTokens() ) {
                  String access = st.nextToken();
                  if ( access != null ) {
                      String trimed = access.trim();
                      if ( trimed.length() &gt; 0 ) {
//System.out.println("access: '" + trimed + "'");
                          accesses.add(trimed);
                      }
                  }
              }
          }

          if ( accesses.size() &gt; 0 ) {
              extraInfo.put(ACCESSES, accesses);
          }
      }

      /**
       * Given the eventCode from the native windows event
       * map it to our Action.
       */
      public Action resolveAction(Integer eventCode, HashMap extraInfo) {
          Action action = null;

          if ( eventCode == null ) {
              return;
          }

          try {
              switch(eventCode) {
                  case 538:
                      // logout
                      action = Action.Logout;
                      break;
                  case 528:
                  case 540:
                      // login
                      action = Action.Login;
                      break;
                  case 564:
                      // object delted
                      action = Action.Delete;
                      break;
                  case 560:
                      // object open
                      // Very generic must dig in an check permissions
                      if (containsAccess("WriteAttributes", extraInfo))
                          action = Action.Update;
                      else
                      if ( containsAccess("DELETE", extraInfo) ) 
                          action = Action.Delete;
                      else 
                          action = Action.Read;
                      break;
                  default: 
                      // not sure we should even have a default case?
                      action = Action.Read;
                      break;
              }
          } catch(Exception e) {
              action = null;
          }
          return action;
      }

      /** 
       * Using the resolved action, use the data in the extraInfo
       * map to come up with a target. ( the thing that was acted upon)
       */
      public String resolveTarget(Action action, HashMap extraInfo) {

          String target = null;    
          if ( ( action == null ) || ( extraInfo == null )  ) {
              return target;
          }

          if ( ( action.equals(Action.Login) ) ||
               ( action.equals(Action.Logout) ) ) {
              target = (String)extraInfo.get("Domain");
          } else {
              target = (String)extraInfo.get("Object Name");
          }

          if ( target == null ) target = "unResolved";
          return target;
      }


      /** 
       * Dig into the extra info and see if the event has referece to 
       * the past in access. 
       */
      private boolean containsAccess(String access, HashMap extraInfo) {

          boolean contains = false;
          if ( extraInfo == null ) return contains;

          ArrayList accesses = (ArrayList)extraInfo.get(ACCESSES); 
          if ( accesses != null ) {
              for ( String access: accesses ) {
                  if ( access != null ) {
                      if ( access.compareTo(access) == 0 ) {
                          return true;
                      }
                  }
              }        
          }
          return contains;
      }
    
  </Source>
</Rule>
<Rule language="beanshell" name="System Configured Locale Rule" type="FieldValue">
  <Description>
    This rule returns the locales configured in the System Configuration.
  </Description>
  <Signature returnType="java.util.List">
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="locales">
        <Description>
          A list containing the locales found in the System Configuration.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      import java.util.*;
     Map sysConfig = context.getConfiguration().getAttributes();
     List locales = sysConfig.get("supportedLanguages");
     return locales;
</Source>
</Rule>
<Rule language="beanshell" name="Report Completion Notification" type="TaskEventRule">
  <Description>
    This rule sends a notification email when a report is completed.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="taskResult">
        <Description>
          The TaskResult object
        </Description>
      </Argument>
      <Argument name="event">
        <Description>
          The TaskEvent object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="taskResult">
        <Description>The resulting task result object, or null if no update is required.</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
      
        import sailpoint.object.*;
        import java.util.*;

        String identity = (String)event.getAttribute(TaskEvent.ATTR_EMAIL_RECIP);

        if (identity != null){

          Identity identity = context.getObjectByName(Identity.class, identity);
          if (identity == null)
            return result;

          List emailAddresses = new ArrayList();
          emailAddresses.add(identity.getEmail());
          EmailOptions options = new EmailOptions(emailAddresses, null);
          options.setSendImmediate(true);

          Map emailVars = new HashMap();
          emailVars.put("reportName", taskResult.getName());
          options.setVariables(emailVars);

          String templateName = (String)context.getConfiguration().get(Configuration.REPORT_COMPLETION_EMAIL_TEMPLATE);
          EmailTemplate et = context.getObjectByName(EmailTemplate.class, templateName);

          context.sendEmailNotification(et, options);
        }

        return null;
      
</Source>
</Rule>
<Rule language="beanshell" name="Report Scorecard Value Renderer">
  <Description>
      This rule renders report columns which pull values from a Scorecard object.
    </Description>
  <Source>
      
       import java.util.*;
       import sailpoint.object.*;

       Integer score = null;
       if(value!=null) {
					score = value.getScore(column.getField());
			 }

       return score != null ? score.toString() : null;
      
  </Source>
</Rule>
<Rule language="beanshell" name="Task Completion Email Rule" type="TaskCompletion">
  <Description>
      Example rule to perform Post Action after Task Completion
    </Description>
  <Signature>
    <Inputs>
      <Argument name="context">
        <Description>
            A sailpoint.api.SailPointContext object 
          </Description>
      </Argument>
      <Argument name="log">
        <Description>
            The log object associated with the SailPointContext.
          </Description>
      </Argument>
      <Argument name="result">
        <Description>
            result of task.
          </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
      
          import java.util.*;
          import sailpoint.tools.Util;
          import sailpoint.tools.GeneralException;
          import sailpoint.object.Configuration;
          import sailpoint.object.EmailOptions;
          import sailpoint.object.EmailTemplate;
          import sailpoint.object.TaskResult;
          import sailpoint.object.Identity;
          import sailpoint.object.TaskDefinition;
          import sailpoint.api.MessageRepository;
          import sailpoint.api.Emailer;
          import sailpoint.api.BasicMessageRepository;
          import sailpoint.api.ObjectUtil;
          import sailpoint.api.SailPointContext;

          MessageRepository _errorHandler;

          /**
           * Method to send email
          */
          private void sendEmailOnTaskCompletion(String emailTemplate, ArrayList recipients, TaskResult result, SailPointContext context) {
              String message = "";
              String status = "";
              TaskDefinition def;
              Configuration sysConfig;

              def = result.getDefinition();
              EmailTemplate notifyEmail =  context.getObjectByName(EmailTemplate.class, emailTemplate);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: could not find email template [ " + emailTemplate + "]");
                  return;
              }
              notifyEmail = (EmailTemplate) notifyEmail.deepCopy(context);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: failed to deepCopy template [ " + emailTemplate + "]");
                  return;
              }
              // For now, we'll just use a map with a few pre-selected properties.
              Map mArgs = new HashMap();
 
              mArgs.put("taskResult", result);
              mArgs.put("taskName", def.getName());
              mArgs.put("taskDesc", def.getDescription());
              if (result.isError()) {
                  status = "Error";
              }
              else  if (result.isWarning()) {
                  status = "Warning";
              }
              else if (result.isSuccess()) {
                  status = "Success";
              }
 
              mArgs.put("taskStartTime", result.getLaunched() );
              mArgs.put("taskEndTime", result.getCompleted() );
              mArgs.put("status", status);
              if (result.getMessages() != null) {
                  mArgs.put("message", result.getMessages());
              }
              mArgs.put ("resultId", result.getId());

              EmailOptions ops = new EmailOptions(recipients, mArgs);
              new Emailer(context, _errorHandler).sendEmailNotification(notifyEmail , ops);
          }

          private boolean isEmailNotificationEnabled(TaskResult result, Configuration sysConfig) {
              boolean sendEmail = false;
              String notifyStr = null;

              TaskDefinition def = result.getDefinition();
              notifyStr = (String) def.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);
              if (notifyStr == null) {
                  notifyStr = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);
              }

              if (notifyStr != null) {
                  if (notifyStr.equals("Always") ||
                      ((notifyStr.equals("Failure")) &amp;&amp; result.isError()) || 
                      ((notifyStr.equals("Warning")) &amp;&amp;
                       (result.isWarning() || result.isError()))) {
                      sendEmail = true;
                  }
              }
                      
              return sendEmail;
          }

          private Object getIdentityNames(TaskResult result, Configuration sysConfig) {
              
              TaskDefinition def = result.getDefinition();
              Object identityNames = def.getArgument(Configuration.TASK_COMPLETION_RECIPIENTS);
              if (identityNames == null) {
                  identityNames = sysConfig.get(Configuration.TASK_COMPLETION_RECIPIENTS);
              }
              return identityNames;
          }

          private String getEmailTemplate(TaskResult result, Configuration sysConfig) {
              TaskDefinition def = result.getDefinition();
              String emailTemplate = def.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
              if (emailTemplate == null) {
                  emailTemplate = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
                  if (emailTemplate == null)
                      emailTemplate = Configuration.DEFAULT_TASK_COMPLETION_EMAIL_TEMPLATE;
              }
              return emailTemplate;
          }

          private List getEmailAddress (String identityName, SailPointContext context) {
              Identity identity = context.getObjectByName(Identity.class, identityName);
              if (identity != null) 
              {
                  List addresses = ObjectUtil.getEffectiveEmails(context, identity);
                  if (!Util.isEmpty(addresses)) {
                      return(addresses);
                  }
                  else
                  {
                     if(log.isWarnEnabled()) {
                         log.warn("From Task Completion Email Rule: Missing Email Address for Email Recipient: " + identityName );
                     }
                  }
              }
              return (null);
          }

          private ArrayList getEmailRecipient (Object identityNames, SailPointContext context) {
              List recipients;
              String val = null;
              StringTokenizer st = null;
              if (identityNames != null) {
                  recipients = new ArrayList ();
                  // From Task definition, single identity
                  if (identityNames instanceof String  &amp;&amp; !identityNames.contains(",")) {
                      List addresses = getEmailAddress (identityNames.toString(), context);
                      if (addresses != null) {
                         recipients.addAll (addresses);
                      }
                  }
                  // From Task definition, multiple identities
                  else if (identityNames instanceof String  &amp;&amp; identityNames.contains(",") == true) {
                      List nameList = Util.csvToList(identityNames);
                      for (String identityName : nameList) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll (addresses);
                          }
                      }  
                  } 
                  // From system configuration single or multiple identities it comes as list
                  else if (identityNames instanceof List) {
                      for (String identityName : identityNames) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll(getEmailAddress (identityName, context));
                          }
                      }
                  }
              }
              return (recipients);
          }

          // Main
          Configuration sysConfig = context.getConfiguration();
          boolean sendEmailNotify = isEmailNotificationEnabled(result, sysConfig);
    
          if (sendEmailNotify) {
              // jsl - why consturct this here, just make it in
              // sendEmailOnTaskCompletion where it is used?
              // why do this at all since no one consumes it?
              _errorHandler = new BasicMessageRepository();

              Object identityNames = getIdentityNames(result, sysConfig);
              String emailTemplate = getEmailTemplate(result, sysConfig);
              List recipients = getEmailRecipient(identityNames, context);

              if (recipients != null &amp;&amp; !Util.isEmpty(recipients)) {
                    // Send Email
                   sendEmailOnTaskCompletion(emailTemplate, recipients, result, context);
              }
              else {
                  if(log.isWarnEnabled()) {
                      log.warn("From Task Completion Email Rule: Cannot send task completion email Notification. Reason : Missing Email Address for Email Recipients");
                  }
              }
          }
    
    </Source>
</Rule>
<Rule language="beanshell" name="CEFTransformRule" type="ActivityTransformer">
  <Description>ActivityTransformation Rules are used by the LogFileCollector to transform fields parsed from a text file into our ApplicationActivity model.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="action">
        <Description>
          The field named action, which is the raw parsed.
          action field.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="mappedAction">
        <Description>
          A normalized ApplicationActivity.Action object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ApplicationActivity.Action;
import sailpoint.object.ApplicationActivity.Result;
import java.text.SimpleDateFormat;
import java.io;
import sailpoint.object.Configuration;
import java.util.List;

activity.setAction(Action.Grant);
activity.setResult(Result.Success);

//Dump out all params from CEF log entry to console
//System.out.println("CEFTransformRule: In rule");        
//System.out.println("CEFTransformRule: Timestamp=" +cef_timestamp);
//System.out.println("CEFTransformRule: Host=" +cef_host);
//System.out.println("CEFTransformRule: CEFVersion=" + cef_cefversion);
//System.out.println("CEFTransformRule: Vendor=" + cef_vendor);
//System.out.println("CEFTransformRule: Product=" + cef_product);
//System.out.println("CEFTransformRule: Version=" + cef_version);
//System.out.println("CEFTransformRule: Signature=" + cef_signature);
//System.out.println("CEFTransformRule: Name=" + cef_name);
//System.out.println("CEFTransformRule: Severity=" + cef_severity);
//System.out.println("CEFTransformRule: Explanation=" + cef_explanation);

//Find the user parameter in CEF Explanation field
//System.out.println("CEFTransformRule: Breaking down the parameter list.....:");

Object o= Configuration.getSystemConfig().getList(Configuration.ATT_CEF_USER_NAME);
List cefUserNames = null;
if (o instanceof List) {
            cefUserNames = (List)o;
}

for (String paramPair: cef_explanation.split("\\s(?=\\S*(?&lt;!\\\\)=)", 0)){
//	System.out.println("CEFTransformRule: Parameter pair found " + paramPair);
    for(String cefUser: cefUserNames){
        String cefUserParam = cefUser.concat("=.*");
        if (paramPair.matches(cefUserParam)) {
            cef_user = paramPair.split("=",2)[1];
//            System.out.println("CEFTransformRule: duser parameter found! " + cef_user);
        }
    }   
}

// Set activity values
activity.setUser(cef_user);
activity.setAction(Action.Login);
activity.setResult(Result.Success);
activity.setInfo("vendor=" + cef_vendor + " host=" + cef_host + " " + cef_explanation + " severity=" + cef_severity + " product=" + cef_product);
activity.setTarget(cef_name);

// Set timestamp from CEF header, but add current year as this is not supplied
SimpleDateFormat f = new SimpleDateFormat("MMM dd hh:mm:ss yyyy");
defaultYear = Calendar.getInstance().get(Calendar.YEAR);
Date date = date = f.parse(cef_timestamp + " " + defaultYear);
activity.setTimeStamp(date);

return activity;</Source>
</Rule>
<Rule language="beanshell" name="CEFActivityCorrelation" type="ActivityCorrelation">
  <Description>Rule to show how an CEF activity might be correlated back to an identity. In most cases, this rule will be providing enought information to the correlator so that it can find the Application link. In some cases, it might also be desireable to return something that points back to an Identity, which is also supported.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application where the activity was generated.
          An application may have more then one data source.
        </Description>
      </Argument>
      <Argument name="datasource">
        <Description>
          The data source that returned the activity.
        </Description>
      </Argument>
      <Argument name="activity">
        <Description>
          The activity object that was normalized by
          the data source and that we are trying to
          correlate back to one of our Identities.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="linkIdentity">
        <Description>
          A string that represents the link's identity attribute.
        </Description>
      </Argument>
      <Argument name="linkName">
        <Description>
          A string that represents the link's displayName attribute.
        </Description>
      </Argument>
      <Argument name="linkAttributeName">
        <Description>
          A string that represents the NAME of an attribute that
          can be used to find the Link that maps back to this
          activity.  This attribute must also be supplied
          with the linkAttributeValue variable.
        </Description>
      </Argument>
      <Argument name="linkAttributeValue">
        <Description>
          A string that represents the VALUE of an attribute that
          can be used to find the Link that maps back to this
          activity. This attribute must also be supplied
          with the linkAttributeName variable.
        </Description>
      </Argument>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object in case the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.ApplicationActivity;
  import sailpoint.object.Configuration;
	
//  System.out.println("CEFActivityCorrelation: In Correlation Rule");

    Map returnMap = new HashMap();
    String user = activity.getUser();
	String cefLinkAttributeName = Configuration.getSystemConfig().getString(Configuration.ATT_CEF_LINK_ATTRIBUTE_NAME);
	
    if ( user != null ) {
//		System.out.println("CEFActivityCorrelation: Matching for user " + user);
        returnMap.put("linkAttributeName", cefLinkAttributeName);
        returnMap.put("linkAttributeValue", user);
//        System.out.println("returnMap " + returnMap);
    }

    return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Universal" type="Correlation">
  <Description>A universal correlation rule for use at Sallie Mae, this will attempt to match the account name against multiple targets in the following order 1. Whole Account Name against personID 2. Truncated Account Name against personID, where it has been truncated to A#####
3. Whole Account name against NED-ApplicationIDs to find an SRP, which is used to find a personID 4. Truncated Account Name against NED-ApplicationIDs to find an SRP, which is used to find a personID</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account">
        <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          Existing link to this account.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import org.apache.commons.logging.Log;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import sailpoint.api.SailPointContext;
import sailpoint.object.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

Logger log = Logger.getLogger("smb.rulelog");

String ruleName = "***Universal Correlation: " + application.getName() + "***";
log.setLevel(Level.INFO);
log.info(ruleName + " Entering");

//Ideally we want an account of the form #AAAAA
String accountIdentity = account.getIdentity();
String accountDisplayName = account.getDisplayName();

Pattern activeDirectoryEmployeePattern = Pattern.compile("CN=([aecv]\\d{5})", Pattern.CASE_INSENSITIVE);
Matcher idMatch = activeDirectoryEmployeePattern.matcher(accountIdentity);

Pattern activeDirectoryPattern = Pattern.compile("Active Directory");
Matcher activeDirectoryMatch = activeDirectoryPattern.matcher(application.getName());

Pattern employeePattern = Pattern.compile("([aecvAECV]\\d{5})",Pattern.CASE_INSENSITIVE);

if (idMatch.find()) {
  netLogin = idMatch.group(1);
} else if (activeDirectoryMatch.find()) {
  netLogin = accountDisplayName;
} else netLogin = accountIdentity;

Map returnMap = new HashMap();

String personIdAttributeValue = null;

//First, attempt to match the account with the personID of an Identity Cube
log.info(ruleName + "Attempting first match");
QueryOptions qo = new QueryOptions();
qo.add(Filter.ignoreCase(Filter.eq("personID",netLogin)));
qo.add(Filter.eq("correlated",true));
log.info(ruleName + "Attempting to match " + netLogin);
List identityResults = context.getObjects(Identity.class, qo);


Identity id = null;

//If we found one and only one result, correlate with that identity
if(identityResults.size() == 1) {
    id = identityResults.get(0);
    log.info(ruleName + "Direct identity correlation with netLogin");
} 

//First attempt to match a version of the login ID trimmed down to:
// (#AAAAA)
if (id == null) {
    log.info(ruleName + "Attempting truncated netLogin match with identity");
    Matcher match = employeePattern.matcher(netLogin);

    if (match.find()) {
         log.info(ruleName + "Attempting match with truncated netLogin: " + match.group(1));
         qo = new QueryOptions();
         qo.add(Filter.ignoreCase(Filter.eq("personID",match.group(1))));
         qo.add(Filter.eq("correlated",true));
         identityResults = context.getObjects(Identity.class,qo);
         
          //If we matched an entry correlate with that identity
          if(identityResults.size() == 1) {
            id = identityResults.get(0);
            log.info(ruleName + "Direct identity correlation with truncated netLogin");
          } 
    }
}

if(id == null)
{

    //If the above didn't work we need to try and match it with the list from the NED-ApplicationIDs
    //First we'll try and match the entire thing
    log.info(ruleName + " Attempting srp match");
    qo = new QueryOptions();
    qo.add(Filter.eq("application.name", "NED-ApplicationIDs"));
    qo.add(Filter.ignoreCase(Filter.eq("displayName", netLogin)));
    List linkResults = context.getObjects(Link.class, qo);

    //If we found one and only one result, attempt correlate with the owner of that account using their SRP
    if (linkResults.size() == 1) {
        log.info(ruleName + "Found NED-ApplicationIDs link.");
        //First retrieve the "srp" from the account
        Link link = linkResults.get(0);
        String srp = link.getAttribute("srp");

        //Try and find an identity SRP
        qo = new QueryOptions();
        qo.add(Filter.ignoreCase(Filter.eq("personID", srp)));
        qo.add(Filter.eq("correlated",true));
        identityResults = context.getObjects(Identity.class, qo);

        //If we found only one result correlate with that identity
        if (identityResults.size() == 1) {
            id = identityResults.get(0);
            log.info(ruleName + "SRP Correlation with full netlogin");
        } else log.info("ruleName + Could not associate SRP " + srp + " with an identity.");
        
    } else log.info("ruleName + Could not associate possible application account with NED-ApplicationIDs");   
}    

if(id == null &amp;&amp; link != null)
{

    //If the above didn't match and the account is of the form of an application ID with an extra letter:
    // e.g. (a#####[a-zA-Z]) attempt to match a NED-ApplicationIDs account by removing the last letter
    log.info(ruleName + "Second match attempt failed, attempting truncated SRP match.");
    Pattern p = Pattern.compile("(^[a]\\d{5})[a-z]", Pattern.CASE_INSENSITIVE);
    Matcher match = p.matcher(netLogin);
    if (match.find()) {

        String srp = link.getAttribute("srp");

        //Try and find an identity SRP
        qo = new QueryOptions();
        qo.add(Filter.eq("application.name", "NED-ApplicationIDs"));
        qo.add(Filter.ignoreCase(Filter.eq("displayName", match.group(1))));
        List linkResults = context.getObjects(Link.class, qo);

        log.info(ruleName + "Truncated version is " + match.group(1));

        //If we found one and only one result, attempt correlate with the owner of that account using their SRP
        if (linkResults.size() == 1) {

            //Retrieve the "srp" from the account
            Link link = linkResults.get(0);
            String srp = link.getAttribute("srp");

            //Try and find an identity SRP
            qo = new QueryOptions();
            qo.add(Filter.ignoreCase(Filter.eq("personID", srp)));
            qo.add(Filter.eq("correlated",true));
            identityResults = context.getObjects(Identity.class, qo);

            //If we found only one result correlate with that identity
            if (identityResults.size() == 1) {
                id = identityResults.get(0);
                log.info(ruleName + "SRP Correlation with truncated netLogin");
            }
        }
    } else log.info(ruleName + "Application style netid not found"); 
}


if (id != null) {
    personIdAttributeValue = id.getAttribute("personID");
} else {
    log.info(ruleName + "Correlation failed for account " + netLogin);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", personIdAttributeValue);

log.info(ruleName + "Exiting Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Customization-Workday-Termination-Date" type="ResourceObjectCustomization">
  <Description>This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.

Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.</Description>
  <Signature returnType="ResourceObject">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="object">
        <Description>
          The ResourceObject built by the connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application that references the connector.
        </Description>
      </Argument>
      <Argument name="connector">
        <Description>
          The connector object.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="resourceObject">
        <Description>
          The updated resource object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import java.util.Arrays;
import java.text.SimpleDateFormat;
import java.util.Date;

//Put the users manager in the form of an  E number
if (object.get("MANAGER_ID") != NULL) {
  object.put("MANAGER_ID","e" + object.get("MANAGER_ID"));
}


//This is from the customer, anyone termed on this date or before was never in the "New Sallie Mae"
String discard_date_string = "05/01/2014";

try {

if (object.get("TERMINATION_DATE") == NULL) {
	return object;
	}
else {

	String termination_date_string = object.get("TERMINATION_DATE");

	SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");

	Date discard_date = sdf.parse(discard_date_string);
	Date terminate_date = sdf.parse(termination_date_string);


	//If the user was terminated after the discard date then return their object, otherwise, return nothing
	if(terminate_date.compareTo(discard_date) &gt; 0) {
		return object;
	}
	else {
		return NULL;
	}
}

} catch (Exception e) {

	return object;

}</Source>
</Rule>
<Rule language="beanshell" name="Correlation-TSRA" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

log.info("Entering TSRA Account Correlation Rule");

String netLogin = account.getStringAttribute("LOGIN");
log.info("***netLogin = " + netLogin);

Map returnMap = new HashMap();

String retVal = null;

if (netLogin != null &amp;&amp; netLogin.toLowerCase().startsWith("smb.")) {
  log.info("Inside condition, account that matches pattern smb.* is: " +  netLogin);
  retVal = netLogin.substring(4);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting TSRA Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="GroupOwner-Managers" type="GroupOwner">
  <Description>A rule used to assign owners to groups generated from a group factory.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="factory">
        <Description>
          The GroupFactory that generated the populations.
        </Description>
      </Argument>
      <Argument name="group">
        <Description>
          One GroupDefinition from the factory.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="owner">
        <Description>
          The group owner. The name or id of an Identity or the Identity object itself.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("Entering rule: Set group owner display name");

if (group.getName() != null) {
    log.info("[*]Group Owner Manager: " + group.getName());
    return group.getName();
} else {
    log.info("[*]Group Owner Manager: NULL - Return spadmin");
    return "spadmin";
}
log.info("Exiting rule: Set group owner display name");</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-NED-Vendors-setDisplayName" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String"/>
  <Source>import sailpoint.object.Link;
  import org.apache.commons.lang.WordUtils;
  import org.apache.log4j.Logger;
  import org.apache.log4j.Level; 
  
  Logger log = Logger.getLogger("smb.rulelog");
  log.setLevel(Level.INFO);
  log.info("entering rule: Derive Display Name Attribute Rule");
  
  String middle = "";
  String dnRet = "";
  String first = "";
  String last = "";
  
  if(link.getApplicationName().equals("NED-Vendors")) { 
    first = link.getAttribute("first_name");
    log.info("fname= " +first);
    last = link.getAttribute("last_name");
    log.info("lname= " +last);
    if ((link.getAttribute("first_name") !=null) &amp;&amp; (link.getAttribute("last_name") !=null)) {
      dnRet = WordUtils.capitalize(last.toLowerCase()) +", "+WordUtils.capitalize(first.toLowerCase());
      log.info("Display Name = "+dnRet);
    }
  }
  log.info("exiting rule: Derive Display Name Attribute Rule");
  return dnRet;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-NED-Lenders-setDisplayName" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String"/>
  <Source>import sailpoint.object.Link;
  import org.apache.commons.lang.WordUtils;
  import org.apache.log4j.Logger;
  import org.apache.log4j.Level; 
  
  Logger log = Logger.getLogger("smb.rulelog");
  log.setLevel(Level.INFO);
  log.info("entering rule: Derive Display Name Attribute Rule");
  
  String middle = "";
  String dnRet = "";
  String first = "";
  String last = "";
  
  if(link.getApplicationName().equals("NED-Lenders")) { 
    first = link.getAttribute("first_name");
    log.info("fname= " +first);
    last = link.getAttribute("last_name");
    log.info("lname= " +last);
    if ((link.getAttribute("first_name") !=null) &amp;&amp; (link.getAttribute("last_name") !=null)) {
      dnRet = WordUtils.capitalize(last.toLowerCase()) +", "+WordUtils.capitalize(first.toLowerCase());
      log.info("Display Name = "+dnRet);
    }
  }
  log.info("exiting rule: Derive Display Name Attribute Rule");
  return dnRet;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-Workday-setUserType" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String"/>
  <Source>import sailpoint.object.Link;
  import sailpoint.tools.Util;
  import java.util.regex.Pattern;
  import java.util.regex.Matcher;
  import org.apache.log4j.Logger;
  import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Derive User Type Attribute Rule for Workday Direct");

String uType = "";
String employeeId = link.getAttribute("FILENUMBER");
log.info("FILENUMBER = " + employeeId);

if (employeeId != null) {
  Pattern p = Pattern.compile("(^[c]\\d{5}[a-zA-Z]?)", Pattern.CASE_INSENSITIVE);
  Matcher match = p.matcher(employeeId);
  boolean m = match.find();
  if (m == true) {
    uType = "Contractor";
    log.info("Returning userType value = Contractor for: " + employeeId); 
  } else {
    uType = "Employee";
    log.info("Returning userType value = Employee for: " + employeeId);
  }
}

log.info("exiting rule: Derive User Type Attribute Rule for Workday Direct");

return uType;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-NED-Lenders-setUserType" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
      </Argument>
      <Argument name="attributeSource">
        <Description>
          The AttributeSource object.
        </Description>
      </Argument>
      <Argument name="oldValue">
        <Description>
          The original value of the application account attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Link;
import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Derive User Type Attribute Rule for NED-Lenders");

String userType = null;
String lenderUserId = link.getAttribute("lender_user_id");
if (link.getAttribute("lender_user_id") != null) {
    if (lenderUserId.substring(0, 1).toLowerCase().equals("b")) {
        userType = "Lender Board Member";
        log.info("Returning userType value = Lender Board Member for: " + lenderUserId);
    } else if (lenderUserId.substring(0, 1).toLowerCase().equals("l")) {
        userType = "Lender";        
        log.info("Returning userType value = Lender for: " + lenderUserId);
    }
}

log.info("exiting rule: Derive User Type Attribute Rule for NED-Lenders");

return userType;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-NED-Vendors-setUserType" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
      </Argument>
      <Argument name="attributeSource">
        <Description>
          The AttributeSource object.
        </Description>
      </Argument>
      <Argument name="oldValue">
        <Description>
          The original value of the application account attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Link;
import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Derive User Type Attribute Rule for NED-Vendors");

String userType = " ";
String vendorUserId = link.getAttribute("vendor_user_id");
if (link.getAttribute("vendor_user_id") != null) {
    if (vendorUserId.substring(0, 1).toLowerCase().equals("v")) {
        userType = "Vendor";
        log.info("Returning userType value = Vendor for: " + vendorUserId);
    } else {
        log.info("Returning null or empty userType value for: " + vendorUserId);
    }
}

log.info("exiting rule: Derive User Type Attribute Rule for NED-Vendors");

return userType;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-Workday-setEmploymentStatus" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
      </Argument>
      <Argument name="attributeSource">
        <Description>
          The AttributeSource object.
        </Description>
      </Argument>
      <Argument name="oldValue">
        <Description>
          The original value of the application account attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import org.apache.commons.logging.Log;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import sailpoint.api.IdentityService;
import sailpoint.api.SailPointContext;
import sailpoint.object.AttributeDefinition;
import sailpoint.object.AttributeSource;
import sailpoint.object.Identity;
import sailpoint.object.Link;
import sailpoint.object.Application;

import java.util.List;
import java.util.Map;
 
Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Set Employment Status Rule for Workday Direct Connect");

String applicationName = "Workday Direct Connect";
Application applicationObject = context.getObjectByName(Application.class,applicationName);
String FILENUMBER = "";

String eStatus = "Inactive"; //Assume Inactive until proved otherwise

IdentityService idServ = new IdentityService(context);

List links = idServ.getLinks(identity,applicationObject);

if (links != null) for (Link link : links) {

    FILENUMBER = link.getAttribute("FILENUMBER");
    if (!link.getAttribute("IIQDisabled")) {
        eStatus = "Active";
    }


}

log.info("Setting Employment Status to: " + eStatus + " for FILENUMBER: " + FILENUMBER);
log.info("exiting rule:  Set Employment Status Rule for Workday Direct Connect");
return eStatus;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-NEDLenders-setEmploymentStatus" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String"/>
  <Source>import sailpoint.object.Link;
  import sailpoint.tools.Util;
  import org.apache.log4j.Logger;
  import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Set Employment Status Rule for NED-Lenders");

String eStatus = null;
String employeeId = link.getAttribute("lender_user_id");
String acctStatus = link.getAttribute("account_status");

if (acctStatus != null &amp;&amp; acctStatus.toLowerCase().trim().equals( "t")) {
   eStatus = "Inactive";
   log.info("Setting Employment Status to: " + eStatus + " for Lender ID: " + employeeId);
} else {
   eStatus = "Active";
   log.info("Setting Employment Status to: " + eStatus + " for Lender ID: " + employeeId);
}

log.info("exiting rule:  Set Employment Status Rule for NED-Lenders");

return eStatus;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-NEDVendors-setEmploymentStatus" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String"/>
  <Source>import sailpoint.object.Link;
  import sailpoint.tools.Util;
  import org.apache.log4j.Logger;
  import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Set Employment Status Rule for NED-Vendors");

String eStatus = null;
String employeeId = link.getAttribute("vendor_user_id");
String acctStatus = link.getAttribute("account_status");

if (acctStatus != null &amp;&amp; acctStatus.toLowerCase().trim().equals( "t")) {
   eStatus = "Inactive";
   log.info("Setting Employment Status to: " + eStatus + " for Vendor ID: " + employeeId);
} else {
   eStatus = "Active";
   log.info("Setting Employment Status to: " + eStatus + " for Vendor ID: " + employeeId);
}

log.info("exiting rule:  Set Employment Status Rule for NED-Vendors");

return eStatus;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-Workday-setUserID" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
      </Argument>
      <Argument name="attributeSource">
        <Description>
          The AttributeSource object.
        </Description>
      </Argument>
      <Argument name="oldValue">
        <Description>
          The original value of the application account attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Link;
    import sailpoint.tools.Util;
    import org.apache.log4j.Logger;
    import org.apache.log4j.Level;
    import org.apache.commons.lang.StringUtils;
  	import java.util.Date;
    import java.text.SimpleDateFormat;
    import sailpoint.object.Application;
    import sailpoint.api.IdentityService;
 import java.text.ParseException;
 
    Logger log = Logger.getLogger("smb.rulelog");
    log.setLevel(Level.INFO);
    log.info("entering rule: Set UserID from WorkDay Direct accounts");


    //I'm making an assumption here that there are no term dates this old
    String initial_termination_date_string = "01/01/1000";

    SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");

    Date id_termination_date = sdf.parse(initial_termination_date_string);
    Date account_termination_date = sdf.parse(initial_termination_date_string);


    String applicationName = "WorkDay Direct Connect";
    Application application = context.getObjectByName(Application.class,applicationName);


    String retVal = "";
    String empid = "";
    String uid = "";
    boolean iiqDisabled = false;


    IdentityService idServ = new IdentityService(context);

    List links = idServ.getLinks(identity,application);

    String account_id = null;
    String account_termination_date_string = null;

    if (links != null) for (Link link : links) {

        account_id = link.getAttribute("FILENUMBER");
        account_termination_date_string = link.getAttribute("TERMINATION_DATE");


        if (account_termination_date_string != null) {


            try {
                account_termination_date = sdf.parse(account_termination_date_string);

                // If the termination date on this account link is greater than the termination date on all previous
                // account links, or the default termination date of this comparitor function update the return value
                // with this links employee id and update the date being used for comparisons
                if (account_termination_date.compareTo(id_termination_date) &gt; 0) {
                    empid = link.getAttribute("FILENUMBER");
                    uid = link.getAttribute("USERID");
                    iiqDisabled = link.getAttribute("IIQDisabled");
                    id_termination_date = account_termination_date;
                }
                
            } catch (ParseException pe) {
                // Treat this account as not having a valid termination date
                empid = link.getAttribute("FILENUMBER");
                uid = link.getAttribute("USERID");
                iiqDisabled = link.getAttribute("IIQDisabled");
                break;
            }
            
        } else {
            // Else this account has no termination date and is active, so we should just return this
            empid = link.getAttribute("FILENUMBER");
            uid = link.getAttribute("USERID");
            iiqDisabled = link.getAttribute("IIQDisabled");
            break;
        }

    }


    log.info("***FILENUMBER = " + empid);
    log.info("***USERID = " + uid);

    if (StringUtils.isEmpty(uid) &amp;&amp; empid.substring(0, 1).toLowerCase().equals("c")) {
        retVal = empid;
        log.info("Setting UserID attribute to: " + retVal + " for Contractor: " + empid);
    } else if (uid != null) {
        retVal = uid;
        log.info("Setting UserID attribute to: " + retVal + " for Employee: " + empid);
    }


    log.info("exiting rule: Set UserID for Workday Direct");

    return retVal;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-Workday-setManagerID" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
      </Argument>
      <Argument name="attributeSource">
        <Description>
          The AttributeSource object.
        </Description>
      </Argument>
      <Argument name="oldValue">
        <Description>
          The original value of the application account attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import java.util.Date;
import java.text.SimpleDateFormat;
import sailpoint.object.Application;
import sailpoint.api.IdentityService;
import sailpoint.object.Link;


Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Set ManagerID from WorkDay Direct accounts");



try {

    //I'm making an assumption here that there are no term dates this old
    String initial_termination_date_string = "01/01/1000";

    SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");

    Date id_termination_date = sdf.parse(initial_termination_date_string);
    Date account_termination_date = sdf.parse(initial_termination_date_string);


   String applicationName = "WorkDay Direct Connect";
    Application application = context.getObjectByName(Application.class,applicationName);


    String retVal = "";


    IdentityService idServ = new IdentityService(context);

    List links = idServ.getLinks(identity,application);

    String account_manager_id = null;
    String account_termination_date_string = null;
  
    if (links != null) for (Link link : links) {

        account_manager_id = link.getAttribute("MANAGER_ID");
        account_termination_date_string = link.getAttribute("TERMINATION_DATE");

      
        if (account_termination_date_string != null) {

            account_termination_date = sdf.parse(account_termination_date_string);

            // If the termination date on this account link is greater than the termination date on all previous
            // account links, or the default termination date of this comparitor function update the return value
            // with this links employee id and update the date being used for comparisons
          if (account_termination_date.compareTo(id_termination_date) &gt; 0) {
                   retVal = link.getAttribute("MANAGER_ID");
                   id_termination_date = account_termination_date;
              }

        } else {
            // Else this account has no termination date and is active, so we should just return this
            return link.getAttribute("MANAGER_ID");
        }

    }
  
  	return retVal;
  
} catch (Exception e) {
    log.info("Could not determine EmployeeID for " + identity.getDisplayName());
    return "";
}</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-InternalAD" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String p_appAcct = "(^[a]\\d{5}[a-zA-Z]?)";
String p_appTestAcct = "(^[a]\\d{5}[tT])";
String p_userSecurityAcct = "(^[celv]\\d{5}[sS])";
String p_testAcct = "(^[t]\\d{5}[a-zA-Z]?)";
String p_userTestAcct = "(^[celv]\\d{5}[tT])";

String appId = Util.otos(link.getAttribute("sAMAccountName"));
  
log.info("Entering Internal AD setAccountType Link Attribute Rule");
String acctType = null;

Pattern p_app = Pattern.compile(p_appAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_app = Pattern.compile(p_appTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();
  
// Checking if application test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Test Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 
  
Pattern p_sec = Pattern.compile(p_userSecurityAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_sec.matcher(appId);
boolean m = match.find();

// Checking if security account
if (appId != null) { 
    if (m == true) {
        return acctType = "Security Account";
        log.info("***Found Security Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_tst = Pattern.compile(p_testAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}
    
Pattern p_tst = Pattern.compile(p_userTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if user test account
if (appId != null) { 
    if (m == true) {
        return acctType = "User Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

log.info("***Normal account");
log.info("Exiting Internal AD setAccountType Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-SMBAzureAD" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String p_appAcct = "(^[a]\\d{5}[a-zA-Z]?)";
String p_appTestAcct = "(^[a]\\d{5}[tT])";
String p_userSecurityAcct = "(^[celv]\\d{5}[sS])";
String p_testAcct = "(^[t]\\d{5}[a-zA-Z]?)";
String p_userTestAcct = "(^[celv]\\d{5}[tT])";

String appId = " ";
String acctType = null;

String mnn = Util.otos(link.getAttribute("mailNickname"));
String dn = Util.otos(link.getAttribute("displayName"));
  
log.info("Entering SMB Azure AD setAccountType Link Attribute Rule");

if (mnn != null) {
    // Pre-check if mailNickname matches account naming pattern, if match found set appId to mailNickname
    boolean tmp = false;
    Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z]?)", Pattern.CASE_INSENSITIVE);
    Matcher match = p.matcher(mnn);
    boolean mmnn = match.find();
    if (mmnn == true) {
        appId = mnn;
        log.info("***mailNickname*** matches for account: " + appId);
        tmp = true;
    } else if (dn !=null &amp;&amp; tmp == false) {
        // Pre-check if displayName matches account naming pattern, since MailNickname doesn't match, if match found set appId to displayName
        Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z]?)", Pattern.CASE_INSENSITIVE);
        Matcher match = p.matcher(dn);
        boolean mdn = match.find();
        if (mdn == true) {
            appId = dn;
            log.info("***displayName*** matches for account: " + appId);
        }
    }
} 

// Now that appId is set correctly, start setting privileged account access flags
Pattern p_app = Pattern.compile(p_appAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_app = Pattern.compile(p_appTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();
  
// Checking if application test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Test Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 
  
Pattern p_sec = Pattern.compile(p_userSecurityAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_sec.matcher(appId);
boolean m = match.find();

// Checking if security account
if (appId != null) { 
    if (m == true) {
        return acctType = "Security Account";
        log.info("***Found Security Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_tst = Pattern.compile(p_testAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

Pattern p_tst = Pattern.compile(p_userTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if user test account
if (appId != null) { 
    if (m == true) {
        return acctType = "User Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}
  
log.info("Exiting  SMB Azure AD setAccountType Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-DMZPAD" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String p_appAcct = "(^[a]\\d{5}[a-zA-Z]?)";
String p_appTestAcct = "(^[a]\\d{5}[tT])";
String p_userSecurityAcct = "(^[celv]\\d{5}[sS])";
String p_testAcct = "(^[t]\\d{5}[a-zA-Z]?)";
String p_userTestAcct = "(^[celv]\\d{5}[tT])";

String appId = Util.otos(link.getAttribute("sAMAccountName"));

log.info("Entering DMZP AD setAccountType Link Attribute Rule");
String acctType = null;
  
Pattern p_app = Pattern.compile(p_appAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_app = Pattern.compile(p_appTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Test Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 
  
Pattern p_sec = Pattern.compile(p_userSecurityAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_sec.matcher(appId);
boolean m = match.find();

// Checking if security account
if (appId != null) { 
    if (m == true) {
        return acctType = "Security Account";
        log.info("***Found Security Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_tst = Pattern.compile(p_testAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

Pattern p_tst = Pattern.compile(p_userTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if user test account
if (appId != null) { 
    if (m == true) {
        return acctType = "User Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

log.info("***Normal account");
log.info("Exiting DMZP AD setAccountType Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-PCIInternalAD" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String p_appAcct = "(^[a]\\d{5}[a-zA-Z]?)";
String p_appTestAcct = "(^[a]\\d{5}[tT])";
String p_userSecurityAcct = "(^[celv]\\d{5}[sS])";
String p_testAcct = "(^[t]\\d{5}[a-zA-Z]?)";
String p_userTestAcct = "(^[celv]\\d{5}[tT])";

String appId = Util.otos(link.getAttribute("sAMAccountName"));

log.info("Entering PCI Internal AD setAccountType Link Attribute Rule");
String acctType = null;
  
Pattern p_app = Pattern.compile(p_appAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_app = Pattern.compile(p_appTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Test Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 
  
Pattern p_sec = Pattern.compile(p_userSecurityAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_sec.matcher(appId);
boolean m = match.find();

// Checking if security account
if (appId != null) { 
    if (m == true) {
        return acctType = "Security Account";
        log.info("***Found Security Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_tst = Pattern.compile(p_testAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

Pattern p_tst = Pattern.compile(p_userTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if user test account
if (appId != null) { 
    if (m == true) {
        return acctType = "User Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

log.info("***Normal account");
log.info("Exiting PCI Internal AD setAccountType Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-PCIDMZ" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String p_appAcct = "(^[a]\\d{5}[a-zA-Z]?)";
String p_appTestAcct = "(^[a]\\d{5}[tT])";
String p_userSecurityAcct = "(^[celv]\\d{5}[sS])";
String p_testAcct = "(^[t]\\d{5}[a-zA-Z]?)";
String p_userTestAcct = "(^[celv]\\d{5}[tT])";

String appId = Util.otos(link.getAttribute("sAMAccountName"));

log.info("Entering PCIDMZ AD setAccountType Link Attribute Rule");
String acctType = null;
  
Pattern p_app = Pattern.compile(p_appAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_app = Pattern.compile(p_appTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Test Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 
  
Pattern p_sec = Pattern.compile(p_userSecurityAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_sec.matcher(appId);
boolean m = match.find();

// Checking if security account
if (appId != null) { 
    if (m == true) {
        return acctType = "Security Account";
        log.info("***Found Security Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_tst = Pattern.compile(p_testAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

Pattern p_tst = Pattern.compile(p_userTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if user test account
if (appId != null) { 
    if (m == true) {
        return acctType = "User Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

log.info("***Normal account");
log.info("Exiting PCIDMZ AD setAccountType Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-LinuxOUAD" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment">
        <Description>
          The optional arguments passed from the task executor, if the rule is running within a task.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          The Link whose attribute is being promoted.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="value">
        <Description>
          An Object to be used as the attribute value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String p_appAcct = "(^[a]\\d{5}[a-zA-Z]?)";
String p_appTestAcct = "(^[a]\\d{5}[tT])";
String p_userSecurityAcct = "(^[celv]\\d{5}[sS])";
String p_testAcct = "(^[t]\\d{5}[a-zA-Z]?)";
String p_userTestAcct = "(^[celv]\\d{5}[tT])";

String appId = Util.otos(link.getAttribute("sAMAccountName"));
  
log.info("Entering Linux OU AD setAccountType Link Attribute Rule");
String acctType = null;

Pattern p_app = Pattern.compile(p_appAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();

// Checking if application account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_app = Pattern.compile(p_appTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_app.matcher(appId);
boolean m = match.find();
  
// Checking if application test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Application Test Account";
        log.info("***Found Application Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 
  
Pattern p_sec = Pattern.compile(p_userSecurityAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_sec.matcher(appId);
boolean m = match.find();

// Checking if security account
if (appId != null) { 
    if (m == true) {
        return acctType = "Security Account";
        log.info("***Found Security Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
} 

Pattern p_tst = Pattern.compile(p_testAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if test account
if (appId != null) { 
    if (m == true) {
        return acctType = "Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}
    
Pattern p_tst = Pattern.compile(p_userTestAcct, Pattern.CASE_INSENSITIVE);
Matcher match = p_tst.matcher(appId);
boolean m = match.find();

// Checking if user test account
if (appId != null) { 
    if (m == true) {
        return acctType = "User Test Account";
        log.info("***Found Test Account***, Returning Account Type: " + acctType + "for account: " + appId);
    }
}

log.info("***Normal account");
log.info("Exiting Linux OU AD setAccountType Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountType-NED-ApplicationIDs" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment">
        <Description>
          The optional arguments passed from the task executor, if the rule is running within a task.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          The Link whose attribute is being promoted.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="value">
        <Description>
          An Object to be used as the attribute value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.*;
import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String accType = "Application Account";

log.info("Entering NED-ApplicationIDs setAccountType Link Attribute Rule");
log.info("*** Setting Account Type as Application Account***");
log.info("Exiting NED-ApplicationIDs setAccountType Link Attribute Rule");
return accType;</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-NEDLenders" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("account_status"));
String acct = Util.otos(link.getAttribute("lender_user_id"));
  
log.info("Entering NED-Lenders setAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; status.toLowerCase().trim().equals( "t")) {
    log.info("Found inactive NED-Lender Identity: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active NED-Lender Identity: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting NED-Lenders setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-NEDVendors" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("account_status"));
String acct = Util.otos(link.getAttribute("vendor_user_id"));
  
log.info("Entering NED-Vendors setAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; status.toLowerCase().trim().equals( "t")) {
    log.info("Found inactive NED-VendorIdentity: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active NED-Vendor Identity: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting NED-Vendor setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-NEDApplicationIDs" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("account_status"));
String acct = Util.otos(link.getAttribute("application_user_id"));
  
log.info("Entering NED-ApplicationIDs setAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; status.toLowerCase().trim().equals( "inactive")) {
    log.info("Found inactive NED-ApplicationIDs account: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active NED-ApplicationIDs account: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting NED-ApplicationIDs setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-Accurint" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("status"));
String acct = Util.otos(link.getAttribute("id"));
  
log.info("Entering Accurint setAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; status.toLowerCase().trim().equals( "inactive")) {
    log.info("Found inactive Accurint Identity: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active Accurint Identity: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting Accurint setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-ESIINST" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment">
        <Description>
          The optional arguments passed from the task executor, if the rule is running within a task.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          The Link whose attribute is being promoted.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="value">
        <Description>
          An Object to be used as the attribute value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("status"));
String acct = Util.otos(link.getAttribute("id"));
  
log.info("Entering ESI-INST setAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; status.toLowerCase().trim().equals( "inactive")) {
    log.info("Found inactive ESI-INST Identity: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active ESI-INST Identity: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting ESI-INST setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-TSRA" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object"/>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("ENABLED?"));
String acct = Util.otos(link.getAttribute("LOGIN"));
  
log.info("Entering TSRAsetAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; status.toLowerCase().trim().equals( "disabled")) {
    log.info("Found inactive TSRA Identity: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active TSRA Identity: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting TSRA setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="LinkAttribute-setAccountStatus-InnoviWEB" type="LinkAttribute">
  <Description>This rule is used when promoting account attributes from Links during aggregation.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment">
        <Description>
          The optional arguments passed from the task executor, if the rule is running within a task.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          The Link whose attribute is being promoted.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="value">
        <Description>
          An Object to be used as the attribute value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.tools.Util;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String status = Util.otos(link.getAttribute("status"));
String acct = Util.otos(link.getAttribute("id"));
  
log.info("Entering InnovisWEB setAccountStatus Link Attribute Rule");
String acctStatus = null;

// Checking if application account
if (status != null &amp;&amp; (status.toLowerCase().trim().equals( "inactive") || status.toLowerCase().trim().equals("deactivated"))) {
    log.info("Found inactive InnovisWEB Identity: " + acct + " with account_status = " + status);
     //set IIQDisabled to true for link
    link.setAttribute("IIQDisabled", true);
    return acctStatus = "Inactive";
} else {
    log.info("Found active InnovisWEB Identity: " + acct + " with account_status = " + status);
    return acctStatus = "Active";
}

log.info("Exiting InnovisWEB setAccountStatus Link Attribute Rule");</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ADLinuxOU" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

log.info("Entering AD LinuxOU Account Correlation Rule");

String netLogin = account.getStringAttribute("sAMAccountName");
log.info("***netLogin = " + netLogin);

Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting AD LinuxOU Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-SMBAzureActiveDirectory" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String dname = account.getStringAttribute("displayName");
String mnick = account.getStringAttribute("mailNickName");
Map returnMap = new HashMap();

String retVal = null;
boolean pm = false;
  
log.info("Entering SMB Azure AD Account Correlation Rule");

if (mnick != null) {
  Pattern pmn = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
  Matcher match = pmn.matcher(mnick);
  boolean mmn = match.find();
  //Checking for match on mailNickName 
  if (mmn == true) {
    log.info("Inside condition***mail nickname matched***, account that matches pattern is: " +  mnick);
    retVal = mnick.trim().substring(0,6);
    log.info("***Mail nickname pattern matched***, return value to correlate this account = " + retVal);
    returnMap.put("identityAttributeName", "personID");
    returnMap.put("identityAttributeValue", retVal);
    pm = true;
  }
}  

if (dname != null &amp;&amp; pm == false) {
  Pattern pdn = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z])", Pattern.CASE_INSENSITIVE);
  Matcher match = pdn.matcher(dname);
  boolean mdn = match.find();
  // Checking for match on displayName
  if (mdn == true) {
    log.info("Inside condition***display name matched***, account that matches pattern is: " + dname);
    retVal = dname.trim().substring(0,6);
    log.info("***Display name pattern matched***, return value to correlate this account = " + retVal);
    returnMap.put("identityAttributeName", "personID");
    returnMap.put("identityAttributeValue", retVal);
  }
} 
    
log.info("***No pattern matched*** for display name: " + dname + " or mailNickname: " + mnick);
log.info("Exiting SMB Azure AD Account Correlation Rule");
return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ADDMZP" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("sAMAccountName");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering  AD DMZP Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting AD DMZP Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ADPCIDMZ" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("sAMAccountName");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering AD PCIDMZ Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting AD PCIDMZ Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ADPCIInternal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("sAMAccountName");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering AD PCI Internal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting AD PCI Internal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Katabat" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z]\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Katabat Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Katabat Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Archer" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z]\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Archer Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.trim().substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Archer Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ClearingHouse" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering ClearingHouse Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting ClearingHouse Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-DDI" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering DDI  Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting DDI Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-DeticaLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\_\\.\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Detica-Local Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Detica-Local Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-DMZPLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering  DMZPLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting DMZPLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-DocumentumLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering DocumentumLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting DocumentumLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-EDWNetezza" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering EDWNetezza Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting EDWNetezza Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-EDWNetezzaLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering EDWNetezza-Local Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting EDWNetezza-Local Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-EncoreLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering EncoreLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting EncoreLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ESI" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering ESI Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting ESI Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ESI-INST" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering ESI-INST Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting ESI-INST Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-FDR" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering FDR Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting FDR Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Informatica-LOCAL" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import org.apache.commons.logging.Log;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import sailpoint.api.SailPointContext;
import sailpoint.object.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("Entering Applications Local Account Correlation Rule");

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String personIdAttributeValue = null;

//First, attempt to match the account with the personID of an Identity Cube
log.info("Attempting first match");
QueryOptions qo = new QueryOptions();
qo.add(Filter.ignoreCase(Filter.eq("personID",netLogin)));
log.info("Attempting to match " + netLogin);
List identityResults = context.getObjects(Identity.class, qo);


Identity id = null;

//If we found one and only one result, correlate with that identity
if(identityResults.size() == 1) {
    id = identityResults.get(0);
    log.info("Direct identity correlation with netLogin");
} 

//If that didn't work try and match on a truncated version of a standard form employee id
// (#AAAAA)
if (id == null) {
    log.info("Attempting truncated netLogin match with identity");
    Pattern p = Pattern.compile("(^[aecv]\\d{5})[a-z]", Pattern.CASE_INSENSITIVE);
    Matcher match = p.matcher(netLogin);

    if (match.find()) {

         qo = new QueryOptions();
         qo.add(Filter.ignoreCase(Filter.eq("personID",match.group(1))));
         identityResults = context.getObjects(Identity.class,qo);
         
          //If we matched an entry correlate with that identity
          if(identityResults.size() == 1) {
            id = identityResults.get(0);
            log.info("Direct identity correlation with truncated netLogin");
          } 
    }
}

if(id == null)
{

    //If the above didn't work we need to try and match it with the list from the NED-ApplicationIDs
    //First we'll try and match the entire thing
    log.info("First match failed, attempting srp match");
    qo = new QueryOptions();
    qo.add(Filter.eq("application.name", "NED-ApplicationIDs"));
    qo.add(Filter.ignoreCase(Filter.eq("displayName", netLogin)));
    List linkResults = context.getObjects(Link.class, qo);

    //If we found one and only one result, attempt correlate with the owner of that account using their SRP
    if (linkResults.size() == 1) {
        log.info("Found NED-ApplicationIDs link.");
        //First retrieve the "srp" from the account
        Link link = linkResults.get(0);
        String srp = link.getAttribute("srp");

        //Try and find an identity SRP
        qo = new QueryOptions();
        qo.add(Filter.ignoreCase(Filter.eq("personID", srp)));
        identityResults = context.getObjects(Identity.class, qo);

        //If we found only one result correlate with that identity
        if (identityResults.size() == 1) {
            id = identityResults.get(0);
            log.info("SRP Correlation with full netlogin");
        } else log.info("Could not associate SRP " + srp + " with an identity.");
        
    } else log.info("Could not associate possible application account with NED-ApplicationIDs");   
}    

if(id == null)
{

    //If the above didn't match and the account is of the form of an application ID with an extra letter:
    // e.g. (a#####[a-zA-Z]) attempt to match a NED-ApplicationIDs account by removing the last letter
    log.info("Second match attempt failed, attempting truncated SRP match.");
    Pattern p = Pattern.compile("(^[a]\\d{5})[a-z]", Pattern.CASE_INSENSITIVE);
    Matcher match = p.matcher(netLogin);
    if (match.find()) {

        String srp = link.getAttribute("srp");

        //Try and find an identity SRP
        qo = new QueryOptions();
        qo.add(Filter.eq("application.name", "NED-ApplicationIDs"));
        qo.add(Filter.ignoreCase(Filter.eq("displayName", match.group(1))));
        List linkResults = context.getObjects(Link.class, qo);

        log.info("Truncated version is " + match.group(1));

        //If we found one and only one result, attempt correlate with the owner of that account using their SRP
        if (linkResults.size() == 1) {

            //Retrieve the "srp" from the account
            Link link = linkResults.get(0);
            String srp = link.getAttribute("srp");

            //Try and find an identity SRP
            qo = new QueryOptions();
            qo.add(Filter.ignoreCase(Filter.eq("personID", srp)));
            identityResults = context.getObjects(Identity.class, qo);

            //If we found only one result correlate with that identity
            if (identityResults.size() == 1) {
                id = identityResults.get(0);
                log.info("SRP Correlation with truncated netLogin");
            }
        }
    } else log.info("Application style netid not found"); 
}


if (id != null) {
    personIdAttributeValue = id.getAttribute("personID");
} else {
    log.info("Correlation failed for account " + netLogin);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", personIdAttributeValue);

log.info("Exiting Applications Local Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Internal-LOCAL" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Internal-Local Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Internal-LOCAL Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-KanaUpromise" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z]\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering KanaUpromise Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting KanaUpromise Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-LiveChat-LivePerson" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering LiveChat-LivePerson Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting LiveChat-LivePerson Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-OpenNet" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering OpenNet Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting OpenNet Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Oracle" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Oracle Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Oracle Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-OracleUpromise" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering OracleUpromise Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting OracleUpromise Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-PCIDMZLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering PCIDMZLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting PCIDMZLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-PeopleSoftLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering PeopleSoftLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting PeopleSoftLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Principia" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Principia Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Principia Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-PrincipiaLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering PrincipiaLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting PrincipiaLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-SASLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering SAS-Local Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting SAS-Local Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Speedpay" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Speedpay Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Speedpay Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-SQLProd" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering SQLProd Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting SQLProd Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Transunion" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Transunion Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Transunion Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-UpromiseLocal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering UPromiseLocal Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting UPromiseLocal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Equifax" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Equifax Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Equifax Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-FNI" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering FNI Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting FNI Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Monetize" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z]\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Monitise Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Monitise Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ProdAzure" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Prod.Azure Doamin Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Prod.Azure Doamin Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Remitco" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Remitco Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Remitco Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-SocialMoney" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering SocialMoney Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting SocialMoney Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-UPRBackOffice" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering UPRBackOffice Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting UPRBackOffice Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-UpromiseCRS" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering UpromiseCRS Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting UpromiseCRS Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-WebCSRAdmin" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = " ";

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering WebCSRAdmin Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting WebCSRAdmin Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="IdentityCreation-setPWD" type="IdentityCreation">
  <Description>Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.

One common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).

Another common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.</Description>
  <Signature returnType="void">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account" type="ResourceObject">
        <Description>
          The resource account for the identity being created.
        </Description>
      </Argument>
      <Argument name="identity" type="Identity">
        <Description>
          The identity that is being created.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>identity.setPassword("SallieMae!");</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Accurint" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Accurint Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.trim().substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Accurint Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-Experian" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("id");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\_\\-])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Experian Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Experian Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ADInternal" type="Correlation">
  <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

log.info("Entering AD Internal Account Correlation Rule");

String netLogin = account.getStringAttribute("sAMAccountName");
log.info("***netLogin = " + netLogin);

Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting AD Internal Account Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="Test - Open File">
  <Source>
 
 
import java.io.*;
import java.lang.String;
 
 
InputStream is;
 
    try {
        is = new FileInputStream("/\/\s617985ch3nas01/\SailPoint_Extracts/\SailPoint_Extracts/\CMC_User_Report_20171204.csv");
        is.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
 
System.out.println("We got here, so we must have been able to open the file!");
   
BufferedReader br = new BufferedReader(new FileReader("/\/\s617985ch3nas01/\SailPoint_Extracts/\SailPoint_Extracts/\CMC_User_Report_20171204.csv"));
 
        String line = null;
         while ((line = br.readLine()) != null) {
            System.out.println(line + "\n");
        }
 
 
 
</Source>
</Rule>
<Rule language="beanshell" name="Secondary Account Customization" type="ResourceObjectCustomization">
  <Description>This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.

Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.</Description>
  <Signature returnType="ResourceObject">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="object">
        <Description>
          The ResourceObject built by the connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application that references the connector.
        </Description>
      </Argument>
      <Argument name="connector">
        <Description>
          The connector object.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="resourceObject">
        <Description>
          The updated resource object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.level;

Logger log = Logger.getLogger("smb.rulelog");

String displayNameVal = account.getStringAttribute("sAMAccountName");
Map returnMap = new HashMap();

Pattern patternN = Pattern.compile("(^[acev]\\d{5}[a-zA-Z])", Pattern.CASE_INSENSITIVE);
Matcher matcher = patternN.matcher(displayNameVal);
boolean m = matcher.find();

if(m == true)
{
 
  log.info("Entering AD Account Customization Rule");
  log.debug("Inside condition......: " +  displayNameVal);
  displayNameVal = displayNameVal.substring(0,6);
  log.debug("New displayName: " + displayNameVal);
}    
returnMap.put("identityAttributeName", "displayName");
returnMap.put("identityAttributeValue", displayNameVal);
return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="AccountGroup-AD" type="GroupAggregationRefresh">
  <Description>This rule is used to set the owner or modify the account group before it is persisted to the database.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="obj" type="ResourceObject">
        <Description>
          A sailpoint.object.ResourceObject generated from the application
          and the ProvisioningPlan's ObjectRequest.
        </Description>
      </Argument>
      <Argument name="accountGroup" type="ManagedAttribute">
        <Description>
          The account group being refreshed.
        </Description>
      </Argument>
      <Argument name="groupApplication" type="Application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="accountGroup" type="ManagedAttribute">
        <Description>
          The refreshed account group object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import java.util.List;
import java.util.ArrayList;
import javax.naming.ldap.LdapName;
import sailpoint.object.*;
import sailpoint.api.*;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
 
Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
 
String ownerDN = null;
String ownerName = null;
Identity identity = null;
 
Object owner = obj.getAttribute("managedBy");
Object fullname = null;
 
log.info("Entering: AccountGroup Refresh Rule");
 
if(owner instanceof List) {
  ownerDN = (String)owner.get(0);
} else {
  ownerDN = (String)owner;
}
 
if(ownerDN != null) {
  LdapName ln = new LdapName(ownerDN);
  if (ln.getRdns().size() &gt; 1) {
    fullname = ln.getRdn(ln.size() - 1).getValue();
    ownerName = (String)fullname;
    log.info("Setting ownername to: " + ownerName);
  } else {
    ownerName = ln.getRdn(0).getValue();
    log.info("Setting ownername to: " + ownerName);
  }
}
 
if (null != ownerName) {
  if (!ownerName.contains(",")) {
    // Query the identity with filter "personID"
    QueryOptions qo = new QueryOptions();
    qo.addFilter(Filter.eq("personID", ownerName));
    List owners = context.getObjects(Identity.class, qo);
    identity = owners.get(0);
  } else {
    // Query the Identity with filter "distinguishedName"
    QueryOptions qo = new QueryOptions();
    qo.addFilter(Filter.eq("distinguishedName", ownerDN));
    List owners = context.getObjects(Identity.class, qo);
    identity = owners.get(0);
  }
}
 
if (null != identity) {
  accountGroup.setOwner(identity);
}
 
log.info("Exiting: AccountGroup Refresh Rule");
return accountGroup;</Source>
</Rule>
<Rule language="beanshell" name="IdentityAttribute-Workday-setEmployeeID" type="IdentityAttribute">
  <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
  <Signature returnType="String"/>
  <Source>import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import java.util.Date;
import java.text.SimpleDateFormat;
import sailpoint.object.Application;
import sailpoint.api.IdentityService;
import sailpoint.object.Link;


Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("entering rule: Set UserID from WorkDay Direct accounts");



try {

    //I'm making an assumption here that there are no term dates this old
    String initial_termination_date_string = "01/01/1000";

    SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");

    Date id_termination_date = sdf.parse(initial_termination_date_string);
    Date account_termination_date = sdf.parse(initial_termination_date_string);


   String applicationName = "WorkDay Direct Connect";
    Application application = context.getObjectByName(Application.class,applicationName);


    String retVal = "";


    IdentityService idServ = new IdentityService(context);

    List links = idServ.getLinks(identity,application);

    String account_id = null;
    String account_termination_date_string = null;
  
    if (links != null) for (Link link : links) {

        account_id = link.getAttribute("FILENUMBER");
        account_termination_date_string = link.getAttribute("TERMINATION_DATE");

      
        if (account_termination_date_string != null) {

            account_termination_date = sdf.parse(account_termination_date_string);

            // If the termination date on this account link is greater than the termination date on all previous
            // account links, or the default termination date of this comparitor function update the return value
            // with this links employee id and update the date being used for comparisons
          if (account_termination_date.compareTo(id_termination_date) &gt; 0) {
                   retVal = link.getAttribute("FILENUMBER");
                   id_termination_date = account_termination_date;
              }

        } else {
            // Else this account has no termination date and is active, so we should just return this
            return link.getAttribute("FILENUMBER");
        }

    }
  
  	return retVal;
  
} catch (Exception e) {
    log.info("Could not determine EmployeeID for " + identity.getDisplayName());
    return "";
}</Source>
</Rule>
<Rule language="beanshell" name="Correlation-ApplicationsLocal" type="Correlation">
  <Signature returnType="Map"/>
  <Source>import sailpoint.object.*;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

String netLogin = account.getStringAttribute("Account");
Map returnMap = new HashMap();

String retVal = null;

Pattern p = Pattern.compile("(^[abcelv]\\d{5}[a-zA-Z\\.\\-\\_])", Pattern.CASE_INSENSITIVE);
Matcher match = p.matcher(netLogin);
boolean m = match.find();

log.info("Entering Applications Local Account Correlation Rule");

if (m == true) {
  log.info("Inside condition, account that matches pattern is: " +  netLogin);
  retVal = netLogin.substring(0,6);
  log.info("Value to be returned to correlate this account = " + retVal);
} else {
  retVal = netLogin;
  log.info("No pattern matched, so value to be returned to correlate this account = " + retVal);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", retVal);

log.info("Exiting Applications Local Correlation Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="BuildMap-Multiplex-Detica-Rule" type="BuildMap">
  <Description>This rule is used by the delimited file connector to build a map representation of the delimited data.</Description>
  <Source>import java.util.Map;
import sailpoint.connector.*;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);

log.info("Entering Local Applications/Multiplex BuildMap Rule");

Map map = DelimitedFileConnector.defaultBuildMap(cols, record);
  
if (schema.getObjectType().compareTo(Connector.TYPE_ACCOUNT) == 0) {
  String applName = (String) map.get("Application");
  if (applName.equals("DR-Detica") || applName.equals("Prod-Detica")) {
    log.info("Got application: " + applName);
    String userId = (String) map.get("Account");
    if (userId.substring(0, 4).toLowerCase().equals("ggr_") || userId.substring(0, 4).toLowerCase().equals("lgr_")) {
      log.info("No link created for account: " + userId + " for application: " + applName);
    } else {
      log.info("Creating link for account: " + userId + " for application: " + applName);
      map.put( "IIQSourceApplication", applName);
      map.put( "IIQMultiplexIdentity", userId);
    }
  }  
}

log.info("Exiting Local Applications/Multiplex BuildMap Rule");
return map;</Source>
</Rule>
<Rule language="beanshell" name="test-Correlation-Universal">
  <Description>A universal correlation rule for use at Sallie Mae, this will attempt to match the account name against multiple targets in the following order 1. Whole Account Name against personID 2. Truncated Account Name against personID, where it has been truncated to A#####
3. Whole Account name against NED-ApplicationIDs to find an SRP, which is used to find a personID 4. Truncated Account Name against NED-ApplicationIDs to find an SRP, which is used to find a personID</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name="account">
        <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
      </Argument>
      <Argument name="link">
        <Description>
          Existing link to this account.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="identityName">
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeName">
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name="identityAttributeValue">
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import org.apache.commons.logging.Log;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import sailpoint.api.SailPointContext;
import sailpoint.object.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

Logger log = Logger.getLogger("smb.rulelog");

String ruleName = "***Test Universal Correlation***";
log.setLevel(Level.INFO);
log.info(ruleName + " Entering");

//Ideally we want an account of the form #AAAAA
String accountIdentity ="E77260S";
String accountDisplayName = "E77260S";
String netLogin = "";

Pattern activeDirectoryEmployeePattern = Pattern.compile("CN=([aecv]\\d{5})", Pattern.CASE_INSENSITIVE);
Matcher idMatch = activeDirectoryEmployeePattern.matcher(accountIdentity);

Pattern activeDirectoryPattern = Pattern.compile("Active Directory");
Matcher activeDirectoryMatch = activeDirectoryPattern.matcher("Encore-LOCAL");

Pattern employeePattern = Pattern.compile("([aecv]\\d{5})");

if (idMatch.find()) {
  netLogin = idMatch.group(1);
} else if (activeDirectoryMatch.find()) {
  netLogin = accountDisplayName;
} else netLogin = accountIdentity;

Map returnMap = new HashMap();

String personIdAttributeValue = null;

//First, attempt to match the account with the personID of an Identity Cube
log.info(ruleName + "Attempting first match");
QueryOptions qo = new QueryOptions();
qo.add(Filter.ignoreCase(Filter.eq("personID",netLogin)));
qo.add(Filter.eq("correlated",true));
log.info(ruleName + "Attempting to match " + netLogin);
List identityResults = context.getObjects(Identity.class, qo);


Identity id = null;

//If we found one and only one result, correlate with that identity
if(identityResults.size() == 1) {
    id = identityResults.get(0);
    log.info(ruleName + "Direct identity correlation with netLogin");
} 

//Attempt to match a version of the login ID trimmed down to:
// (#AAAAA)
if (id == null) {
    log.info(ruleName + "Attempting truncated netLogin match with identity");
    Matcher match = employeePattern.matcher(netLogin);

    if (match.find()) {
         log.info(ruleName + "Attempting match with truncated netLogin: " + match.group(1));
         qo = new QueryOptions();
         qo.add(Filter.ignoreCase(Filter.eq("personID",match.group(1))));
         qo.add(Filter.eq("correlated",true));
         identityResults = context.getObjects(Identity.class,qo);
         
          //If we matched an entry correlate with that identity
          if(identityResults.size() == 1) {
            id = identityResults.get(0);
            log.info(ruleName + "Direct identity correlation with truncated netLogin");
          } 
    }
}

if(id == null)
{

    //If the above didn't work we need to try and match it with the list from the NED-ApplicationIDs
    //First we'll try and match the entire thing
    log.info(ruleName + " Attempting srp match");
    qo = new QueryOptions();
    qo.add(Filter.eq("application.name", "NED-ApplicationIDs"));
    qo.add(Filter.ignoreCase(Filter.eq("displayName", netLogin)));
    List linkResults = context.getObjects(Link.class, qo);

    //If we found one and only one result, attempt correlate with the owner of that account using their SRP
    if (linkResults.size() == 1) {
        log.info(ruleName + "Found NED-ApplicationIDs link.");
        //First retrieve the "srp" from the account
        Link link = linkResults.get(0);
        String srp = link.getAttribute("srp");

        //Try and find an identity SRP
        qo = new QueryOptions();
        qo.add(Filter.ignoreCase(Filter.eq("personID", srp)));
        qo.add(Filter.eq("correlated",true));
        identityResults = context.getObjects(Identity.class, qo);

        //If we found only one result correlate with that identity
        if (identityResults.size() == 1) {
            id = identityResults.get(0);
            log.info(ruleName + "SRP Correlation with full netlogin");
        } else log.info("ruleName + Could not associate SRP " + srp + " with an identity.");
        
    } else log.info("ruleName + Could not associate possible application account with NED-ApplicationIDs");   
}    

if(id == null &amp;&amp; link != null)
{

    //If the above didn't match and the account is of the form of an application ID with an extra letter:
    // e.g. (a#####[a-zA-Z]) attempt to match a NED-ApplicationIDs account by removing the last letter
    log.info(ruleName + "Second match attempt failed, attempting truncated SRP match.");
    Pattern p = Pattern.compile("(^[a]\\d{5})[a-z]", Pattern.CASE_INSENSITIVE);
    Matcher match = p.matcher(netLogin);
    if (match.find()) {

        String srp = link.getAttribute("srp");

        //Try and find an identity SRP
        qo = new QueryOptions();
        qo.add(Filter.eq("application.name", "NED-ApplicationIDs"));
        qo.add(Filter.ignoreCase(Filter.eq("displayName", match.group(1))));
        List linkResults = context.getObjects(Link.class, qo);

        log.info(ruleName + "Truncated version is " + match.group(1));

        //If we found one and only one result, attempt correlate with the owner of that account using their SRP
        if (linkResults.size() == 1) {

            //Retrieve the "srp" from the account
            Link link = linkResults.get(0);
            String srp = link.getAttribute("srp");

            //Try and find an identity by SRP
            qo = new QueryOptions();
            qo.add(Filter.ignoreCase(Filter.eq("personID", srp)));
            qo.add(Filter.eq("correlated",true));
            identityResults = context.getObjects(Identity.class, qo);

            //If we found only one result correlate with that identity
            if (identityResults.size() == 1) {
                id = identityResults.get(0);
                log.info(ruleName + "SRP Correlation with truncated netLogin");
            }
        }
    } else log.info(ruleName + "Application style netid not found"); 
}


if (id != null) {
    personIdAttributeValue = id.getAttribute("personID");
} else {
    log.info(ruleName + "Correlation failed for account " + netLogin);
}

returnMap.put("identityAttributeName", "personID");
returnMap.put("identityAttributeValue", personIdAttributeValue);
returnMap.put("Name",id.getName());

log.info(ruleName + "Exiting Rule");

return returnMap;</Source>
</Rule>
<Rule language="beanshell" name="CertificationExclusion-excludeInactiveAccounts" type="CertificationExclusion">
  <Description>This rule is an example Certification Exclusion rule that removes all of the certifiable items from a certification if the identity being certified is marked as inactive.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="entity" type="AbstractCertifiableEntity">
        <Description>
          The AbstractCertifiableEntity that is part of the certification.
          Currently, this is either an Identity, ManagedAttribute, or Bundle.
        </Description>
      </Argument>
      <Argument name="certification" type="Certification">
        <Description>
          The certification that this identity is part of.
        </Description>
      </Argument>
      <Argument name="certContext" type="CertificationContext">
        <Description>
          The CertificationContext that is being used to generate the
          certification.
        </Description>
      </Argument>
      <Argument name="items" type="List">
        <Description>
          List of Certifiable items that are currently part of the
          certification for this identity.  Any items that should be excluded
          from the certification should be deleted from this list and added
          to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="itemsToExclude" type="List">
        <Description>
          A List of Certifiable items that should not be included in the
          certification.  This list will be empty when the rule is executed
          and any items that should not be part of the certification should
          be moved from the items list to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="explanation" type="String">
        <Description>
          An optional explanation describing why the items were excluded.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Application;
import sailpoint.object.Certifiable;
import sailpoint.object.Entitlements;
import sailpoint.object.Link;
import sailpoint.object.Custom;
import sailpoint.object.Identity;
import org.apache.commons.logging.Log;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;;
    
Logger log = Logger.getLogger("smb.rulelog");
log.setLevel(Level.INFO);
log.info("Entering certification exclusion excludeInactiveAccounts Rule");
String explanation = null;

//Exclude any inactive application accounts.                                      
for (Iterator it = items.iterator(); it.hasNext();) {
        Certifiable certifiable = (Certifiable) it.next();
        if (certifiable instanceof Entitlements) {
        // Get the nativeIdentity and application used to find the particular account.
                Entitlements entitlements = (Entitlements) certifiable;
                Application application = entitlements.getApplicationObject(context);
                String nativeIdentity = entitlements.getNativeIdentity();
                String acct = application.getName() + "-" + nativeIdentity;
                log.info("Got instance of entitlements for: " + acct);
                // Add support for application instances.
                String instanceName = entitlements.getInstance();
                // Get the account link that is associated with the CertifiableItem.  Find by application and nativeIdentity.
                Link account = null;
                if ((null == instanceName) || (instanceName.length() == 0)) {
                    account = identity.getLink(application, nativeIdentity);
                    log.info("Got instancename account: " + account);
                } else {
                    // Pass in the instance name to get the account.
                    account = identity.getLink( application, instanceName, nativeIdentity );
                    log.info("Got nonInstance account: " + account);
                }
                // End support for application instances.
                // Once we have an account, get the inactive attribute. This determines if the CertifiableItem comes from an active or inactive account.
                Object inactiveFlag = null;
                if (account != null){
                        inactiveFlag = account.getAttribute("IIQDisabled"); 
                        log.info("account not null, got IIQDisabled value of: " + inactiveFlag + " for account: " + account);
                }
                // Make sure we have the inactive flag value.
                if(inactiveFlag != null){
                        if ( inactiveFlag instanceof String ) {
                                if (inactiveFlag.trim().equals("true")){
                                    it.remove();
                                    itemsToExclude.add( certifiable );
                                    explanation = "Disabled account, excluded from certification.";
                                    log.info("Account " + nativeIdentity + " on " + application.getName() + " excluded from certification because it disabled.");
                                }
                        } else if (inactiveFlag instanceof Boolean) {
                                if (inactiveFlag) {
                                    it.remove();
                                    itemsToExclude.add( certifiable );
                                    explanation = "Disabled account, excluded from certification.";
                                    log.info("Account " + nativeIdentity + " on " + application.getName() + " excluded from certification because it disabled.");
                                }
                        }
                } else {
                    log.info("Account " + nativeIdentity + " on " + application.getName() + " included in certification because it is active.");
                   log.info("Display Name: " + entitlements.getDisplayName());
                }
        }
}
return explanation;
log.info("Exiting certification exclusion excludeInactiveAccounts Rule");</Source>
</Rule>
<Rule language="beanshell" name="CertificationPreDelegation-reassignCertsForSLMExecs" type="CertificationPreDelegation">
  <Description>A pre-delegation rule that is run on every CertificationEntity when the certification is generated in order to cause some entities to be pre-delegated.  As an example, a manager certification could pre-delegate the certification responsibility to each employee that reports to the manager.  This would allow each subordinate to first determine what they need access to, then allow the manager to review their decision.</Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification being created.
        </Description>
      </Argument>
      <Argument name="entity">
        <Description>
          The sailpoint.object.CertificationEntity to possibly pre-delegate.
        </Description>
      </Argument>
      <Argument name="certContext">
        <Description>
          The sailpoint.api.CertificationContext generating this certification.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="recipientName">
        <Description>
        The name of the Identity that should certify this entity.  Either
        this or 'recipient' should be non-null if pre-delegation should be
        performed.
        </Description>
      </Argument>
      <Argument name="recipient">
        <Description>
        The Identity that should certify this entity.  Either this or
        'recipientName' should be non-null if pre-delegation should be
        performed.
        </Description>
      </Argument>
      <Argument name="description">
        <Description>
        Optional description to set on the delegation WorkItem.  If null, a
        default description of 'Certify [entity name]' is used.
        </Description>
      </Argument>
      <Argument name="comments">
        <Description>
        Optional comments to set on the delegation WorkItems.
        </Description>
      </Argument>
      <Argument name="reassign">
        <Description>
        Optional boolean to specify to reassign rather than delegate.
        </Description>
      </Argument>
      <Argument name="certificationName">
        <Description>
        Optional String to specify the name for the reassignment certification
        if creating a new certification for reassignment.  This is ignored for
        delegations.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.*;

Map results = new HashMap();

String uerTeamName = "SPIIQ Admins";
String execGroupDef = "SLM Executive Team";

String identityName = entity.getIdentity();

String managerId = null;
String identityDisplayName = null;
QueryOptions mgrQueryOps = new QueryOptions();
mgrQueryOps.addFilter(Filter.eq("name", identityName));

List fields = new ArrayList();
fields.add("manager.id");
fields.add("displayName");

Iterator mgrQueryResults = context.search(Identity.class, mgrQueryOps, fields);
if (mgrQueryResults.hasNext()){
    Object[] row = mgrQueryResults.next();
    managerId = row[0];
    identityDisplayName = row[1];
}

if (identityDisplayName == null){
    identityDisplayName = identityName;
}

boolean isExec = false;
if (managerId != null){
    GroupDefinition definition = context.getObjectByName(GroupDefinition.class, execGroupDef);
    Filter f = definition.getFilter();
    List filters = new ArrayList();
    filters.add(f);
    filters.add(Filter.eq("id", managerId));
    QueryOptions ops = new QueryOptions();
    ops.addFilter(Filter.and(filters));
    isExec = context.countObjects(Identity.class, ops) &gt; 0;
}

if (isExec){
    results.put("recipientName", uerTeamName);
    results.put("description", "Please certify on behalf on the executive team.");
    results.put("comments", "This is the access currently granted to " + identityDisplayName + ". Please determine whether it is appropriate for their job function on behalf of the executive team.");
    results.put("reassign", true);
}

return results;</Source>
</Rule>
<Rule language="beanshell" name="CertificationExclusion-excludeCorrelatedAccounts" type="CertificationExclusion">
  <Description>This rule is an example Certification Exclusion rule that removes all of the certifiable items from a certification if the identity being certified is marked as inactive.</Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="entity" type="AbstractCertifiableEntity">
        <Description>
          The AbstractCertifiableEntity that is part of the certification.
          Currently, this is either an Identity, ManagedAttribute, or Bundle.
        </Description>
      </Argument>
      <Argument name="certification" type="Certification">
        <Description>
          The certification that this identity is part of.
        </Description>
      </Argument>
      <Argument name="certContext" type="CertificationContext">
        <Description>
          The CertificationContext that is being used to generate the
          certification.
        </Description>
      </Argument>
      <Argument name="items" type="List">
        <Description>
          List of Certifiable items that are currently part of the
          certification for this identity.  Any items that should be excluded
          from the certification should be deleted from this list and added
          to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="itemsToExclude" type="List">
        <Description>
          A List of Certifiable items that should not be included in the
          certification.  This list will be empty when the rule is executed
          and any items that should not be part of the certification should
          be moved from the items list to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name="state">
        <Description>
          A Map containing state information.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="explanation" type="String">
        <Description>
          An optional explanation describing why the items were excluded.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>import sailpoint.object.Entitlements;
import sailpoint.object.Application;
import sailpoint.object.Identity;
import sailpoint.object.QueryOptions;
import sailpoint.object.Filter;
import sailpoint.object.Certifiable;

import sailpoint.object.Link;
import sailpoint.api.IdentityService;

import java.util.List;
import sailpoint.api.SailPointContext;
import org.apache.commons.logging.Log;
import sailpoint.api.CertificationContext;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import java.util.Iterator;

String explanation = "";
//testing
String logHeader = "Exclusion Rule: Removing Inactive Accounts";
log.info(logHeader + ": Starting Rule Again....");
    if (entity.getManager() != null) {
        for (Object item : items) {
            itemsToExclude.add(item);
        }

        items.clear();
        explanation = "Correlated account excluded from certification, account reviewed during manager certification.";
    } else {

//Exclude any inactive application accounts.                                      
for (Iterator it = items.iterator(); it.hasNext();) {
        Certifiable certifiable = (Certifiable) it.next();
        if (certifiable instanceof Entitlements) {
        // Get the nativeIdentity and application used to find the particular account.
                Entitlements entitlements = (Entitlements) certifiable;
                Application application = entitlements.getApplicationObject(context);
                String nativeIdentity = entitlements.getNativeIdentity();
                String acct = application.getName() + "-" + nativeIdentity;
                log.info("Got instance of entitlements for: " + acct);
                // Add support for application instances.
                String instanceName = entitlements.getInstance();
                // Get the account link that is associated with the CertifiableItem.  Find by application and nativeIdentity.
                Link account = null;
                if ((null == instanceName) || (instanceName.length() == 0)) {
                    account = identity.getLink(application, nativeIdentity);
                    log.info("Got instancename account: " + account);
                } else {
                    // Pass in the instance name to get the account.
                    account = identity.getLink( application, instanceName, nativeIdentity );
                    log.info("Got nonInstance account: " + account);
                }
                // End support for application instances.
                // Once we have an account, get the inactive attribute. This determines if the CertifiableItem comes from an active or inactive account.
                Object inactiveFlag = null;
                if (account != null){
                        inactiveFlag = account.getAttribute("IIQDisabled"); 
                        log.info("account not null, got IIQDisabled value of: " + inactiveFlag + " for account: " + account);
                }
                // Make sure we have the inactive flag value.
                if(inactiveFlag != null){
                        if ( inactiveFlag instanceof String ) {
                                if (inactiveFlag.trim().equals("true")){
                                    it.remove();
                                    itemsToExclude.add( certifiable );
                                    explanation = "Disabled account, excluded from certification.";
                                    log.info("Account " + nativeIdentity + " on " + application.getName() + " excluded from certification because it disabled.");
                                }
                        } else if (inactiveFlag instanceof Boolean) {
                                if (inactiveFlag) {
                                    it.remove();
                                    itemsToExclude.add( certifiable );
                                    explanation = "Disabled account, excluded from certification.";
                                    log.info("Account " + nativeIdentity + " on " + application.getName() + " excluded from certification because it disabled.");
                                }
                        }
                } else {
                    log.info("Account " + nativeIdentity + " on " + application.getName() + " included in certification because it is active.");
                }
        		}
				}
    }
return explanation;</Source>
</Rule>
<Rule language="beanshell" name="CertificationExclusionRule-excludeManagedAccounts-InactiveAccountExclusionDisabled" type="CertificationExclusion">
  <Description>This rule is an example Certification Exclusion rule that removes all of the certifiable items from a certification if the identity being certified is marked as inactive.</Description>
  <Signature returnType="String"/>
  <Source>import sailpoint.object.Entitlements;
import sailpoint.object.Application;
import sailpoint.object.Identity;
import sailpoint.object.QueryOptions;
import sailpoint.object.Filter;
import sailpoint.object.Certifiable;

import sailpoint.object.Link;
import sailpoint.api.IdentityService;

import java.util.List;
import sailpoint.api.SailPointContext;
import org.apache.commons.logging.Log;
import sailpoint.api.CertificationContext;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import java.util.Iterator;

String explanation = "";

    if (entity.getManager() != null) {
        for (Object item : items) {
            itemsToExclude.add(item);
        }

        items.clear();
        explanation = "Correlated account excluded from certification, account reviewed during manager certification.";
    } else {

//Exclude any inactive application accounts.                                      
for (Iterator it = items.iterator(); it.hasNext();) {
        Certifiable certifiable = (Certifiable) it.next();
        if (certifiable instanceof Entitlements) {
        // Get the nativeIdentity and application used to find the particular account.
                Entitlements entitlements = (Entitlements) certifiable;
                Application application = entitlements.getApplicationObject(context);
                String nativeIdentity = entitlements.getNativeIdentity();
                String acct = application.getName() + "-" + nativeIdentity;
                log.info("Got instance of entitlements for: " + acct);
                // Add support for application instances.
                String instanceName = entitlements.getInstance();
                // Get the account link that is associated with the CertifiableItem.  Find by application and nativeIdentity.
                Link account = null;
                if ((null == instanceName) || (instanceName.length() == 0)) {
                    account = identity.getLink(application, nativeIdentity);
                    log.info("Got instancename account: " + account);
                } else {
                    // Pass in the instance name to get the account.
                    account = identity.getLink( application, instanceName, nativeIdentity );
                    log.info("Got nonInstance account: " + account);
                }
                // End support for application instances.
                // Once we have an account, get the inactive attribute. This determines if the CertifiableItem comes from an active or inactive account.
                Object inactiveFlag = null;
                if (account != null){
                        inactiveFlag = account.getAttribute("IIQDisabled"); 
                        log.info("account not null, got IIQDisabled value of: " + inactiveFlag + " for account: " + account);
                }
                // Make sure we have the inactive flag value.
                if(inactiveFlag != null){
                        if ( inactiveFlag instanceof String ) {
                                if (inactiveFlag.trim().equals("true")){
                                    //it.remove();
                                    //itemsToExclude.add( certifiable );
                                    //explanation = "Disabled account, excluded from certification.";
                                    log.info("Account " + nativeIdentity + " on " + application.getName() + " excluded from certification because it disabled.");
                                }
                        } else if (inactiveFlag instanceof Boolean) {
                                if (inactiveFlag) {
                                    //it.remove();
                                    //itemsToExclude.add( certifiable );
                                    //explanation = "Disabled account, excluded from certification.";
                                    log.info("Account " + nativeIdentity + " on " + application.getName() + " excluded from certification because it disabled.");
                                }
                        }
                } else {
                    log.info("Account " + nativeIdentity + " on " + application.getName() + " included in certification because it is active.");
                }
        		}
				}
    }
return explanation;</Source>
</Rule>
</sailpoint>
